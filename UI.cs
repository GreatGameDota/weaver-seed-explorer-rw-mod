using Menu;
using Menu.Remix;
using UnityEngine;
using System.Reflection;

namespace RwLogger;

public class UI : RectangularMenuObject
{
    public SimpleButton warp;
    public MenuTabWrapper wrapper;

    // Adjacency list for all portal connections
    private static readonly Dictionary<string, List<string>> portalConnections = new()
    {
        {"WRFA", new List<string>{"WRFA_D08", "WRFA_F01", "WRFA_A21"}},
        {"WSKA", new List<string>{"WSKA_D13", "WSKA_N04"}},
        {"WSKB", new List<string>{"WSKB_C18", "WSKB_C07"}},
        {"WPGA", new List<string>{"WPGA_B08", "WPGA_B10", "WPGA_E01"}},
        {"WARF", new List<string>{"WARF_B11", "WARF_A06", "WARF_B14", "WARF_D30", "WARF_D06"}},
        {"WRRA", new List<string>{"WRRA_B01", "WRRA_A07", "WRRA_A26"}},
        {"WMPA", new List<string>{"WMPA_A09", "WMPA_D09", "WMPA_C07"}},
        {"WBLA", new List<string>{"WBLA_B08"}},
        {"WTDA", new List<string>{"WTDA_B16", "WTDA_A13"}},
        {"WSKD", new List<string>{"WSKD_B38", "WSKD_B01", "WSKD_B12", "WSKD_B42"}},
        {"WARG", new List<string>{"WARG_B31", "WARG_W11", "WARG_D06_FUTURE", "WARG_A06_FUTURE"}},
        {"WARD", new List<string>{"WARD_E12", "WARD_B41", "WARD_E01", "WARD_E33"}},
        {"WVWA", new List<string>{"WVWA_E01", "WVWA_H01"}},
        {"WVWB", new List<string>{"WVWB_E01"}},
        {"WRFB", new List<string>{"WRFB_B12"}},
        {"WTDB", new List<string>{"WTDB_A19", "WTDB_A04"}},
        {"WSKC", new List<string>{"WSKC_A10"}},
        {"WPTA", new List<string>{"WPTA_C07"}},
        {"WARB", new List<string>{"WARB_F18", "WARB_F01"}},
        {"WARC", new List<string>{"WARC_E11", "WARC_B12"}},
        {"WARE", new List<string>{"WARE_H16", "WARE_H21"}},
        {"WARA", new List<string>()}
    };

    // Lookup table: Key format "NATURAL_PORTAL|NATURAL_PORTAL" -> weight/distance
    // this is unfinished, only like 2 examples of echo -> natural warp or natural warp -> natural warp
    // torrid echo dropoff -> heatducts, stormy echo dropoff -> coldstorage, heatducts torrid -> heatducts salination
    // sali heatducts -> sali fetid, pillargrove coral -> pillargrove torrential, torrential aether -> torrential pillar grove
    // private static readonly Dictionary<string, int> naturalPortalWeights = new()
    // {
    //     // WARF - natural portal to natural portal
    //     {"WARF_B11|WARF_A06", 35}, {"WARF_B11|WARF_B14", 25}, {"WARF_B11|WARF_D30", 40}, {"WARF_B11|WARF_D06", 45},
    //     {"WARF_A06|WARF_B11", 40}, {"WARF_A06|WARF_B14", 40}, {"WARF_A06|WARF_D30", 40}, {"WARF_A06|WARF_D06", 40},
    //     {"WARF_B14|WARF_B11", 30}, {"WARF_B14|WARF_A06", 30}, {"WARF_B14|WARF_D30", 30}, {"WARF_B14|WARF_D06", 30},
    //     {"WARF_D30|WARF_B11", 45},
    //     {"WARF_D06|WARF_B11", 50},

    //     {"WARF_A06|WARF_B14", 45}, {"WARF_B14|WARF_A06", 50},
    //     {"WARF_A06|WARF_D30", 45}, {"WARF_D30|WARF_A06", 50},
    //     {"WARF_A06|WARF_D06", 50}, {"WARF_D06|WARF_A06", 45},
    //     {"WARF_B14|WARF_D30", 20}, {"WARF_D30|WARF_B14", 25},
    //     {"WARF_B14|WARF_D06", 30}, {"WARF_D06|WARF_B14", 35},
    //     {"WARF_D30|WARF_D06", 25}, {"WARF_D06|WARF_D30", 30},

    //     // WRFA - natural portal to natural portal
    //     {"WRFA_D08|WRFA_F01", 35}, {"WRFA_F01|WRFA_D08", 40},
    //     {"WRFA_D08|WRFA_A21", 40}, {"WRFA_A21|WRFA_D08", 45},
    //     {"WRFA_F01|WRFA_A21", 25}, {"WRFA_A21|WRFA_F01", 30},

    //     // WSKA - natural portal to natural portal
    //     {"WSKA_D13|WSKA_N04", 15}, {"WSKA_N04|WSKA_D13", 20},

    //     // WSKB - natural portal to natural portal
    //     {"WSKB_C18|WSKB_C07", 20}, {"WSKB_C07|WSKB_C18", 25},

    //     // WPGA - natural portal to natural portal
    //     {"WPGA_B08|WPGA_B10", 10}, {"WPGA_B10|WPGA_B08", 15},
    //     {"WPGA_B08|WPGA_E01", 45}, {"WPGA_E01|WPGA_B08", 50},
    //     {"WPGA_B10|WPGA_E01", 40}, {"WPGA_E01|WPGA_B10", 45},
    //     {"WARG_W11|WARG_D06_FUTURE", 45}, {"WARG_W11|WARG_A06_FUTURE", 50},
    //     {"WARG_D06_FUTURE|WARG_A06_FUTURE", 30},

    //     // WPGA - natural portal to natural portal
    //     {"WPGA_B08|WPGA_B10", 10}, {"WPGA_B08|WPGA_E01", 45}, {"WPGA_B10|WPGA_E01", 40},

    //     // WRRA - natural portal to natural portal
    //     {"WRRA_B01|WRRA_A07", 35}, {"WRRA_B01|WRRA_A26", 45}, {"WRRA_A07|WRRA_A26", 30},

    //     // WMPA - natural portal to natural portal
    //     {"WMPA_A09|WMPA_D09", 45}, {"WMPA_A09|WMPA_C07", 40}, {"WMPA_D09|WMPA_C07", 35},

    //     // WSKD - natural portal to natural portal
    //     {"WSKD_B38|WSKD_B01", 35}, {"WSKD_B38|WSKD_B12", 40}, {"WSKD_B38|WSKD_B42", 45},
    //     {"WSKD_B01|WSKD_B12", 35}, {"WSKD_B01|WSKD_B42", 40},
    //     {"WSKD_B12|WSKD_B42", 15},

    //     // WTDA - natural portal to natural portal
    //     {"WTDA_B16|WTDA_A13", 40},

    //     // WARD - natural portal to natural portal
    //     {"WARD_E12|WARD_B41", 25}, {"WARD_E12|WARD_E01", 30}, {"WARD_E12|WARD_E33", 45},
    //     {"WARD_B41|WARD_E01", 25}, {"WARD_B41|WARD_E33", 45},
    //     {"WARD_E01|WARD_E33", 35},

    //     // WARE - natural portal to natural portal
    //     {"WARE_H16|WARE_H21", 25},

    //     // WTDB - natural portal to natural portal
    //     {"WTDB_A19|WTDB_A04", 40},

    //     // WVWA - natural portal to natural portal
    //     {"WVWA_E01|WVWA_H01", 35},

    //     // WARB - natural portal to natural portal
    //     {"WARB_F18|WARB_F01", 35},

    //     // WARC - natural portal to natural portal
    //     {"WARC_E11|WARC_B12", 40},
    // };

    // Lookup table: Key format "DYNAMIC_WARP|NATURAL_PORTAL" -> weight/distance
    // These numbers dont take into account how large the destination room is (will take longer between warps) (all except WARF_D29-WARF_D06)
    private static readonly Dictionary<string, int> warpToPortalWeights = new()
    {
        // WARF - dynamic warps to natural portals
        {"WARF_A01|WARF_B11", 45}, {"WARF_A01|WARF_A06", 2}, {"WARF_A01|WARF_B14", 50}, {"WARF_A01|WARF_D30", 45}, {"WARF_A01|WARF_D06", 50},
        {"WARF_B07|WARF_B11", 25}, {"WARF_B07|WARF_A06", 35}, {"WARF_B07|WARF_B14", 45}, {"WARF_B07|WARF_D30", 17}, {"WARF_B07|WARF_D06", 45},
        {"WARF_B23|WARF_B11", 30}, {"WARF_B23|WARF_A06", 45}, {"WARF_B23|WARF_B14", 10}, {"WARF_B23|WARF_D30", 25}, {"WARF_B23|WARF_D06", 35},
        {"WARF_D29|WARF_B11", 45}, {"WARF_D29|WARF_A06", 50}, {"WARF_D29|WARF_B14", 15}, {"WARF_D29|WARF_D30", 20}, {"WARF_D29|WARF_D06", 4},
        
        // WRFA - dynamic warps to natural portals
        {"WRFA_A05|WRFA_D08", 50}, {"WRFA_A05|WRFA_F01", 25}, {"WRFA_A05|WRFA_A21", 45},
        {"WRFA_A07|WRFA_D08", 50}, {"WRFA_A07|WRFA_F01", 15}, {"WRFA_A07|WRFA_A21", 35},
        {"WRFA_A08|WRFA_D08", 50}, {"WRFA_A08|WRFA_F01", 25}, {"WRFA_A08|WRFA_A21", 45},
        {"WRFA_SK02|WRFA_D08", 50}, {"WRFA_SK02|WRFA_F01", 16}, {"WRFA_SK02|WRFA_A21", 36},
        {"WRFA_A12|WRFA_D08", 50}, {"WRFA_A12|WRFA_F01", 3}, {"WRFA_A12|WRFA_A21", 6},
        
        // WSKA - dynamic warps to natural portals
        {"WSKA_D01|WSKA_D13", 4}, {"WSKA_D01|WSKA_N04", 3},
        {"WSKA_D06|WSKA_D13", 2}, {"WSKA_D06|WSKA_N04", 6},
        {"WSKA_D10|WSKA_D13", 2}, {"WSKA_D10|WSKA_N04", 4},
        {"WSKA_D18|WSKA_D13", 2}, {"WSKA_D18|WSKA_N04", 10},
        {"WSKA_D27|WSKA_D13", 12}, {"WSKA_D27|WSKA_N04", 15},
        
        // WSKB - dynamic warps to natural portals
        {"WSKB_C03|WSKB_C18", 20}, {"WSKB_C03|WSKB_C07", 2},
        {"WSKB_C15|WSKB_C18", 25}, {"WSKB_C15|WSKB_C07", 6},
        {"WSKB_N12|WSKB_C18", 2}, {"WSKB_N12|WSKB_C07", 25},
        {"WSKB_N16|WSKB_C18", 2}, {"WSKB_N16|WSKB_C07", 25},
        
        // WARG - dynamic warps to natural portals
        {"WARG_G05|WARG_B31", 50}, {"WARG_G05|WARG_W11", 50}, {"WARG_G05|WARG_D06_FUTURE", 50}, {"WARG_G05|WARG_A06_FUTURE", 50},
        {"WARG_G21|WARG_B31", 5}, {"WARG_G21|WARG_W11", 50}, {"WARG_G21|WARG_D06_FUTURE", 27}, {"WARG_G21|WARG_A06_FUTURE", 50},
        {"WARG_G28|WARG_B31", 50}, {"WARG_G28|WARG_W11", 30}, {"WARG_G28|WARG_D06_FUTURE", 50}, {"WARG_G28|WARG_A06_FUTURE", 50},
        {"WARG_G30|WARG_B31", 50}, {"WARG_G30|WARG_W11", 40}, {"WARG_G30|WARG_D06_FUTURE", 50}, {"WARG_G30|WARG_A06_FUTURE", 50},
        {"WARG_W02|WARG_B31", 50}, {"WARG_W02|WARG_W11", 30}, {"WARG_W02|WARG_D06_FUTURE", 50}, {"WARG_W02|WARG_A06_FUTURE", 50},
        {"WARG_O06_FUTURE|WARG_B31", 15}, {"WARG_O06_FUTURE|WARG_W11", 50}, {"WARG_O06_FUTURE|WARG_D06_FUTURE", 25}, {"WARG_O06_FUTURE|WARG_A06_FUTURE", 45},
        
        // WBLA - dynamic warps to natural portals
        {"WBLA_C02|WBLA_B08", 10},
        {"WBLA_C05|WBLA_B08", 11},
        {"WBLA_D02|WBLA_B08", 7},
        {"WBLA_F04|WBLA_B08", 7},
        
        // WPGA - dynamic warps to natural portals
        {"WPGA_B09|WPGA_B08", 5}, {"WPGA_B09|WPGA_B10", 5}, {"WPGA_B09|WPGA_E01", 45},
        {"WPGA_B12|WPGA_B08", 9}, {"WPGA_B12|WPGA_B10", 6}, {"WPGA_B12|WPGA_E01", 45},
        
        // WRRA - dynamic warps to natural portals
        {"WRRA_B06|WRRA_B01", 10}, {"WRRA_B06|WRRA_A07", 40}, {"WRRA_B06|WRRA_A26", 50},
        {"WRRA_D03|WRRA_B01", 50}, {"WRRA_D03|WRRA_A07", 35}, {"WRRA_D03|WRRA_A26", 5},
        {"WRRA_D04|WRRA_B01", 50}, {"WRRA_D04|WRRA_A07", 40}, {"WRRA_D04|WRRA_A26", 6},
        {"WRRA_D05|WRRA_B01", 50}, {"WRRA_D05|WRRA_A07", 41}, {"WRRA_D05|WRRA_A26", 5},
        
        // WMPA - dynamic warps to natural portals
        {"WMPA_A07|WMPA_A09", 7}, {"WMPA_A07|WMPA_D09", 50}, {"WMPA_A07|WMPA_C07", 50},
        {"WMPA_D03|WMPA_A09", 50}, {"WMPA_D03|WMPA_D09", 4}, {"WMPA_D03|WMPA_C07", 50},
        
        // WRFB - dynamic warps to natural portals
        {"WRFB_B05|WRFB_B12", 50},
        {"WRFB_B08|WRFB_B12", 50},
        {"WRFB_B11|WRFB_B12", 50},
        {"WRFB_D02|WRFB_B12", 50},
        
        // WSKD - dynamic warps to natural portals
        {"WSKD_B05|WSKD_B38", 50}, {"WSKD_B05|WSKD_B01", 4}, {"WSKD_B05|WSKD_B12", 50}, {"WSKD_B05|WSKD_B42", 10},
        {"WSKD_B18|WSKD_B38", 50}, {"WSKD_B18|WSKD_B01", 50}, {"WSKD_B18|WSKD_B12", 3}, {"WSKD_B18|WSKD_B42", 3},
        {"WSKD_B31|WSKD_B38", 13}, {"WSKD_B31|WSKD_B01", 7}, {"WSKD_B31|WSKD_B12", 12}, {"WSKD_B31|WSKD_B42", 10},
        {"WSKD_B35|WSKD_B38", 5}, {"WSKD_B35|WSKD_B01", 12}, {"WSKD_B35|WSKD_B12", 50}, {"WSKD_B35|WSKD_B42", 50},
        
        // WTDA - dynamic warps to natural portals
        {"WTDA_B01|WTDA_B16", 50}, {"WTDA_B01|WTDA_A13", 1},
        {"WTDA_Z04|WTDA_B16", 50}, {"WTDA_Z04|WTDA_A13", 50},
        {"WTDA_Z08|WTDA_B16", 50}, {"WTDA_Z08|WTDA_A13", 50},
        
        // WARD - dynamic warps to natural portals
        {"WARD_D27|WARD_E12", 11}, {"WARD_D27|WARD_B41", 3}, {"WARD_D27|WARD_E01", 16}, {"WARD_D27|WARD_E33", 50}, {"WARD_D27|WARD_R10", 999},
        {"WARD_E02|WARD_E12", 11}, {"WARD_E02|WARD_B41", 5}, {"WARD_E02|WARD_E01", 15}, {"WARD_E02|WARD_E33", 50}, {"WARD_E02|WARD_R10", 999},
        {"WARD_E03|WARD_E12", 11}, {"WARD_E03|WARD_B41", 5}, {"WARD_E03|WARD_E01", 15}, {"WARD_E03|WARD_E33", 50}, {"WARD_E03|WARD_R10", 999},
        {"WARD_R07|WARD_E12", 50}, {"WARD_R07|WARD_B41", 50}, {"WARD_R07|WARD_E01", 35}, {"WARD_R07|WARD_E33", 50}, {"WARD_R07|WARD_R10", 999},
        {"WARD_R16|WARD_E12", 50}, {"WARD_R16|WARD_B41", 50}, {"WARD_R16|WARD_E01", 50}, {"WARD_R16|WARD_E33", 50}, {"WARD_R16|WARD_R10", 999},
        
        // WARE - dynamic warps to natural portals
        {"WARE_H01|WARE_H16", 10}, {"WARE_H01|WARE_H21", 15},
        {"WARE_H02|WARE_H16", 6}, {"WARE_H02|WARE_H21", 8},
        
        // WTDB - dynamic warps to natural portals
        {"WTDB_A06|WTDB_A19", 50}, {"WTDB_A06|WTDB_A04", 2},
        {"WTDB_A10|WTDB_A19", 50}, {"WTDB_A10|WTDB_A04", 3},
        {"WTDB_A13|WTDB_A19", 5}, {"WTDB_A13|WTDB_A04", 10},
        {"WTDB_A15|WTDB_A19", 2}, {"WTDB_A15|WTDB_A04", 50},
        {"WTDB_A17|WTDB_A19", 1}, {"WTDB_A17|WTDB_A04", 45},
        
        // WSKC - dynamic warps to natural portals
        {"WSKC_A05|WSKC_A10", 12},
        {"WSKC_A19|WSKC_A10", 17},
        
        // WVWA - dynamic warps to natural portals
        {"WVWA_D01|WVWA_E01", 40}, {"WVWA_D01|WVWA_H01", 25},
        {"WVWA_F02|WVWA_E01", 50}, {"WVWA_F02|WVWA_H01", 10},
        
        // WVWB - dynamic warps to natural portals
        {"WVWB_H01|WVWB_E01", 20},
        
        // WARB - dynamic warps to natural portals
        {"WARB_F03|WARB_F18", 40}, {"WARB_F03|WARB_F01", 1},
        {"WARB_F11|WARB_F18", 45}, {"WARB_F11|WARB_F01", 50},
        {"WARB_J07|WARB_F18", 50}, {"WARB_J07|WARB_F01", 50},
        
        // WPTA - dynamic warps to natural portals
        {"WPTA_D03|WPTA_C07", 50},
        {"WPTA_G01|WPTA_C07", 50},
        {"WPTA_B06|WPTA_C07", 4},
        {"WPTA_F01|WPTA_C07", 15},
        
        // WARC - dynamic warps to natural portals
        {"WARC_A02|WARC_E11", 50}, {"WARC_A02|WARC_B12", 15},
        {"WARC_A04|WARC_E11", 50}, {"WARC_A04|WARC_B12", 19},
        {"WARC_B08|WARC_E11", 50}, {"WARC_B08|WARC_B12", 50},
        {"WARC_C06|WARC_E11", 50}, {"WARC_C06|WARC_B12", 50}
    };

    private readonly List<int> SEEDS =
    [
        13, 20, 29, 49, 77, 103, 166, 177, 322, 336, 344, 346, 378, 381, 399, 408, 411, 416, 494, 507,
        562, 575, 583, 593, 602, 649, 651, 727, 754, 766, 784, 873, 916, 1059, 1067, 1080, 1132, 1159, 1187, 1194,
        1278, 1286, 1360, 1402, 1420, 1497, 1535, 1543, 1577, 1596, 1608, 1708, 1732, 1754, 1772, 1847, 1885, 1888, 1890, 1954,
        1958, 1976, 1988, 2032, 2059, 2154, 2327, 2340, 2361, 2431, 2448, 2484, 2485, 2501, 2613, 2653, 2673, 2719, 2725, 2889,
        2959, 2983, 3059, 3101, 3106, 3248, 3261, 3278, 3313, 3321, 3351, 3374, 3404, 3496, 3507, 3569, 3606, 3631, 3654, 3665,
        3671, 3695, 3718, 3741, 3748, 3761, 3764, 3774, 3837, 3864, 3908, 3958, 3973, 4015, 4025, 4029, 4157, 4170, 4198, 4247,
        4268, 4390, 4398, 4414, 4516, 4562, 4566, 4593, 4672, 4696, 4729, 4748, 4770, 4781, 4805, 4830, 4831, 4836, 4853, 4944,
        4989, 5018, 5048, 5057, 5074, 5091, 5105, 5115, 5126, 5131, 5192, 5239, 5250, 5273, 5276, 5333, 5444, 5454, 5482, 5568,
        5574, 5576, 5821, 5858, 5875, 5891, 5897, 5914, 5948, 5958, 5967, 6020, 6025, 6043, 6049, 6108, 6117, 6120, 6126, 6155,
        6221, 6243, 6244, 6252, 6255, 6308, 6410, 6414, 6453, 6462, 6535, 6589, 6590, 6649, 6660, 6862, 6884, 6906, 6918, 6942,
        6967, 6991, 7032, 7039, 7050, 7053, 7055, 7087, 7130, 7152, 7181, 7199, 7227, 7258, 7276, 7283, 7335, 7376, 7386, 7413,
        7417, 7480, 7630, 7764, 7776, 7796, 7814, 7841, 7846, 7854, 7867, 7869, 7903, 7926, 7961, 7974, 7976, 7985, 7993, 7997,
        8029, 8110, 8137, 8216, 8217, 8249, 8255, 8318, 8353, 8370, 8384, 8385, 8398, 8409, 8452, 8456, 8531, 8566, 8584, 8591,
        8613, 8639, 8642, 8647, 8682, 8717, 8754, 8786, 8796, 8801, 8802, 8805, 8807, 8815, 8839, 8874, 8911, 9006, 9024, 9069,
        9103, 9107, 9232, 9252, 9304, 9313, 9317, 9319, 9339, 9347, 9351, 9377, 9403, 9406, 9416, 9433, 9539, 9543, 9560, 9570,
        9601, 9647, 9664, 9676, 9707, 9737, 9815, 9832, 9851, 9880, 9910, 9958, 9974, 9976, 9987, 10074, 10081, 10122, 10123, 10152,
        10258, 10284, 10318, 10368, 10378, 10423, 10484, 10531, 10535, 10556, 10646, 10665, 10684, 10706, 10796, 10806, 10848, 10849, 10863, 10910,
        10951, 10965, 10996, 11003, 11026, 11030, 11060, 11076, 11111, 11118, 11127, 11137, 11164, 11210, 11281, 11283, 11291, 11319, 11325, 11353,
        11364, 11382, 11420, 11478, 11482, 11526, 11543, 11607, 11631, 11654, 11686, 11690, 11713, 11757, 11769, 11770, 11887, 11892, 11899, 11907,
        11932, 11942, 11963, 11995, 12059, 12083, 12093, 12170, 12174, 12176, 12191, 12202, 12217, 12283, 12321, 12369, 12470, 12509, 12600, 12653,
        12710, 12712, 12761, 12866, 12908, 12913, 12923, 12968, 12974, 12981, 12999, 13016, 13096, 13130, 13169, 13242, 13251, 13255, 13300, 13324,
        13343, 13347, 13404, 13470, 13514, 13576, 13640, 13691, 13697, 13827, 13858, 13893, 13901, 13920, 13929, 13942, 14005, 14029, 14058, 14110,
        14134, 14154, 14168, 14281, 14287, 14306, 14334, 14371, 14396, 14406, 14498, 14517, 14534, 14552, 14604, 14621, 14628, 14680, 14683, 14713,
        14718, 14741, 14805, 14835, 14843, 14889, 14965, 14989, 15056, 15065, 15067, 15093, 15094, 15133, 15138, 15154, 15163, 15248, 15278, 15322,
        15331, 15337, 15355, 15387, 15393, 15402, 15416, 15451, 15468, 15485, 15495, 15535, 15552, 15555, 15661, 15673, 15675, 15680, 15683, 15688,
        15693, 15710, 15731, 15746, 15770, 15795, 15801, 15813, 15821, 15843, 15866, 15896, 15909, 15913, 15929, 15931, 15934, 16017, 16018, 16088,
        16179, 16194, 16210, 16273, 16301, 16314, 16388, 16455, 16548, 16604, 16657, 16714, 16733, 16815, 16846, 16882, 16897, 16912, 16949, 16986,
        17031, 17058, 17061, 17075, 17089, 17100, 17125, 17145, 17172, 17193, 17217, 17219, 17239, 17263, 17281, 17302, 17337, 17391, 17396, 17424,
        17501, 17506, 17519, 17578, 17607, 17615, 17638, 17655, 17707, 17710, 17713, 17731, 17765, 17811, 17834, 17857, 17879, 17907, 17945, 17982,
        18019, 18052, 18070, 18128, 18207, 18223, 18226, 18246, 18305, 18332, 18340, 18379, 18430, 18442, 18459, 18511, 18516, 18540, 18650, 18653,
        18658, 18666, 18697, 18714, 18736, 18769, 18818, 18850, 18908, 18954, 18969, 19078, 19119, 19156, 19183, 19292, 19304, 19310, 19353, 19360,
        19362, 19365, 19373, 19404, 19410, 19472, 19555, 19575, 19603, 19614, 19620, 19631, 19640, 19674, 19764, 19886, 19892, 19926, 20021, 20069,
        20106, 20139, 20155, 20230, 20268, 20286, 20297, 20299, 20313, 20373, 20447, 20468, 20576, 20586, 20629, 20646, 20653, 20667, 20723, 20739,
        20765, 20784, 20805, 20891, 20926, 20936, 20965, 20987, 20988, 20989, 20994, 21043, 21060, 21063, 21150, 21168, 21180, 21195, 21249, 21251,
        21262, 21282, 21346, 21441, 21442, 21461, 21550, 21598, 21600, 21672, 21697, 21720, 21727, 21746, 21751, 21787, 21821, 21901, 21961, 21982,
        21992, 22034, 22037, 22107, 22108, 22117, 22143, 22208, 22230, 22258, 22307, 22342, 22394, 22429, 22439, 22468, 22471, 22511, 22515, 22586,
        22608, 22627, 22762, 22766, 22880, 22891, 22900, 22903, 22937, 22962, 22970, 22981, 23049, 23051, 23113, 23129, 23165, 23168, 23257, 23311,
        23346, 23369, 23400, 23416, 23438, 23445, 23489, 23577, 23629, 23655, 23667, 23802, 23808, 23821, 23850, 23879, 23922, 23957, 24003, 24032,
        24039, 24044, 24057, 24094, 24148, 24193, 24243, 24305, 24417, 24493, 24501, 24522, 24524, 24563, 24575, 24597, 24703, 24941, 24946, 24959,
        24986, 25020, 25085, 25086, 25110, 25117, 25159, 25162, 25208, 25211, 25261, 25262, 25278, 25330, 25357, 25379, 25395, 25400, 25424, 25431,
        25482, 25608, 25665, 25787, 25856, 25881, 25938, 25983, 26025, 26043, 26048, 26049, 26056, 26075, 26104, 26120, 26134, 26215, 26299, 26310,
        26316, 26332, 26486, 26487, 26544, 26564, 26609, 26621, 26624, 26631, 26632, 26661, 26664, 26702, 26763, 26775, 26794, 26811, 26822, 26825,
        26890, 26950, 26996, 27020, 27043, 27101, 27171, 27195, 27215, 27227, 27267, 27280, 27297, 27325, 27334, 27387, 27392, 27414, 27449, 27455,
        27485, 27605, 27613, 27623, 27635, 27665, 27683, 27717, 27755, 27788, 27797, 27801, 27885, 27892, 27911, 27965, 27990, 28043, 28110, 28113,
        28138, 28139, 28151, 28164, 28191, 28205, 28243, 28263, 28267, 28290, 28302, 28306, 28307, 28333, 28392, 28449, 28476, 28477, 28560, 28621,
        28628, 28649, 28676, 28678, 28684, 28709, 28718, 28719, 28763, 28806, 28882, 28923, 28954, 28964, 29030, 29081, 29085, 29088, 29131, 29184,
        29219, 29225, 29232, 29287, 29299, 29345, 29355, 29517, 29551, 29565, 29670, 29732, 29775, 29828, 29835, 29843, 29854, 29871, 29901, 30022,
        30132, 30150, 30162, 30195, 30224, 30277, 30281, 30306, 30352, 30362, 30411, 30414, 30567, 30573, 30581, 30588, 30590, 30628, 30646, 30665,
        30669, 30701, 30705, 30706, 30746, 30775, 30780, 30788, 30800, 30823, 30871, 30967, 31008, 31064, 31154, 31171, 31172, 31188, 31285, 31303,
        31329, 31400, 31413, 31452, 31484, 31495, 31540, 31550, 31579, 31584, 31706, 31720, 31722, 31737, 31742, 31759, 31760, 31781, 31785, 31788,
        31812, 31895, 31902, 31965, 31975, 32085, 32117, 32132, 32181, 32197, 32204, 32215, 32264, 32287, 32369, 32385, 32428, 32512, 32521, 32544,
        32547, 32550, 32558, 32610, 32612, 32708, 32747, 32886, 32919, 32941, 32968, 33006, 33010, 33011, 33025, 33030, 33063, 33072, 33081, 33222,
        33225, 33342, 33343, 33374, 33379, 33403, 33450, 33495, 33499, 33506, 33585, 33592, 33595, 33605, 33629, 33630, 33648, 33663, 33823, 33856,
        33911, 33922, 33998, 34010, 34019, 34025, 34058, 34063, 34075, 34077, 34082, 34085, 34090, 34148, 34160, 34226, 34237, 34294, 34356, 34376,
        34386, 34443, 34470, 34500, 34510, 34519, 34630, 34641, 34676, 34743, 34797, 34820, 34822, 34846, 34887, 34893, 34981, 35009, 35060, 35080,
        35180, 35278, 35332, 35346, 35383, 35460, 35518, 35570, 35686, 35728, 35742, 35751, 35758, 35772, 35797, 35804, 35834, 35845, 35848, 35854,
        35862, 35874, 35908, 35916, 35950, 35954, 36039, 36089, 36110, 36117, 36189, 36267, 36361, 36362, 36412, 36470, 36482, 36503, 36575, 36577,
        36579, 36599, 36623, 36650, 36689, 36702, 36747, 36750, 36762, 36770, 36869, 36895, 36936, 36959, 37021, 37037, 37051, 37067, 37142, 37155,
        37160, 37187, 37239, 37242, 37258, 37326, 37395, 37407, 37410, 37427, 37487, 37494, 37527, 37637, 37790, 37794, 37814, 37898, 37904, 37958,
        38078, 38216, 38218, 38245, 38252, 38267, 38334, 38387, 38418, 38432, 38545, 38599, 38683, 38685, 38709, 38745, 38758, 38760, 38762, 38768,
        38774, 38840, 38867, 38890, 38908, 38943, 38955, 38959, 39008, 39019, 39032, 39084, 39115, 39117, 39143, 39151, 39192, 39233, 39243, 39485,
        39508, 39555, 39562, 39588, 39606, 39643, 39688, 39833, 39855, 39906, 39922, 39990, 40063, 40079, 40168, 40187, 40242, 40246, 40309, 40325,
        40336, 40342, 40437, 40453, 40460, 40518, 40521, 40526, 40540, 40577, 40598, 40615, 40619, 40633, 40692, 40725, 40775, 40806, 40814, 40833,
        40846, 40855, 40912, 40980, 41019, 41052, 41069, 41151, 41152, 41224, 41276, 41287, 41318, 41321, 41339, 41354, 41365, 41442, 41454, 41502,
        41562, 41593, 41627, 41771, 41816, 41943, 42009, 42032, 42036, 42061, 42072, 42075, 42148, 42182, 42244, 42260, 42274, 42298, 42311, 42331,
        42335, 42374, 42385, 42411, 42478, 42479, 42556, 42622, 42625, 42630, 42637, 42650, 42673, 42678, 42710, 42734, 42737, 42772, 42836, 42927,
        42993, 43009, 43017, 43081, 43089, 43139, 43153, 43179, 43195, 43198, 43216, 43316, 43353, 43357, 43372, 43389, 43399, 43410, 43432, 43441,
        43483, 43547, 43561, 43584, 43641, 43673, 43674, 43704, 43778, 43785, 43853, 43865, 43870, 43915, 43965, 44023, 44111, 44129, 44153, 44192,
        44207, 44230, 44373, 44457, 44468, 44472, 44494, 44558, 44639, 44720, 44736, 44820, 44849, 44850, 44888, 44987, 44989, 45070, 45087, 45158,
        45208, 45243, 45287, 45321, 45343, 45381, 45400, 45407, 45432, 45446, 45476, 45485, 45491, 45548, 45554, 45591, 45631, 45694, 45719, 45757,
        45774, 45823, 45898, 45926, 45929, 45932, 45940, 45951, 45959, 45977, 46005, 46007, 46022, 46064, 46087, 46090, 46113, 46127, 46139, 46169,
        46186, 46193, 46239, 46251, 46281, 46294, 46311, 46312, 46390, 46399, 46466, 46478, 46490, 46513, 46544, 46558, 46584, 46631, 46657, 46703,
        46711, 46735, 46773, 46780, 46790, 46844, 46848, 46865, 46959, 46996, 47012, 47035, 47042, 47051, 47075, 47120, 47186, 47216, 47269, 47271,
        47277, 47296, 47297, 47339, 47360, 47379, 47391, 47471, 47538, 47579, 47612, 47640, 47652, 47663, 47665, 47669, 47673, 47716, 47728, 47774,
        47853, 47871, 47887, 47986, 48003, 48012, 48013, 48079, 48118, 48145, 48196, 48217, 48224, 48226, 48238, 48242, 48255, 48287, 48304, 48305,
        48416, 48488, 48500, 48519, 48536, 48548, 48561, 48584, 48606, 48611, 48673, 48691, 48711, 48717, 48801, 48854, 48886, 48921, 48929, 49023,
        49025, 49039, 49043, 49095, 49101, 49109, 49132, 49169, 49183, 49214, 49226, 49244, 49253, 49300, 49394, 49403, 49422, 49442, 49490, 49534,
        49646, 49815, 49832, 49837, 49841, 49849, 49880, 49885, 49907, 49923, 49931, 49972, 49981, 50079, 50114, 50148, 50155, 50159, 50278, 50302,
        50380, 50417, 50427, 50529, 50614, 50667, 50688, 50689, 50696, 50751, 50770, 50778, 50783, 50798, 50813, 50839, 50875, 50913, 50940, 50943,
        50945, 50996, 51003, 51006, 51024, 51057, 51132, 51206, 51220, 51244, 51250, 51281, 51320, 51347, 51348, 51352, 51367, 51424, 51480, 51523,
        51525, 51532, 51565, 51584, 51622, 51634, 51689, 51751, 51759, 51760, 51795, 51799, 51809, 51819, 51820, 51872, 51912, 51963, 51990, 52030,
        52067, 52098, 52102, 52116, 52133, 52143, 52147, 52177, 52225, 52237, 52321, 52376, 52418, 52434, 52438, 52500, 52520, 52540, 52610, 52626,
        52636, 52638, 52687, 52689, 52729, 52754, 52792, 52800, 52851, 52854, 52905, 52951, 52996, 53003, 53026, 53032, 53062, 53088, 53123, 53148,
        53187, 53198, 53201, 53207, 53261, 53393, 53407, 53423, 53440, 53452, 53484, 53503, 53531, 53569, 53604, 53609, 53612, 53641, 53661, 53664,
        53696, 53727, 53741, 53749, 53765, 53781, 53794, 53842, 53898, 53918, 53932, 53986, 54171, 54228, 54243, 54411, 54461, 54468, 54584, 54585,
        54696, 54708, 54720, 54733, 54752, 54766, 54785, 54835, 54848, 54892, 54926, 54932, 54934, 55084, 55119, 55156, 55225, 55242, 55278, 55320,
        55362, 55369, 55434, 55453, 55505, 55548, 55555, 55562, 55566, 55567, 55638, 55683, 55686, 55708, 55724, 55765, 55783, 55927, 55939, 55995,
        56059, 56095, 56119, 56150, 56274, 56300, 56323, 56329, 56383, 56395, 56490, 56492, 56525, 56552, 56558, 56560, 56562, 56569, 56571, 56617,
        56624, 56631, 56654, 56720, 56756, 56785, 56806, 56926, 56953, 57009, 57111, 57114, 57250, 57258, 57259, 57268, 57338, 57358, 57418, 57454,
        57493, 57498, 57543, 57656, 57660, 57699, 57709, 57719, 57748, 57807, 57838, 57856, 57884, 57895, 57911, 57953, 57959, 57963, 58045, 58046,
        58072, 58135, 58153, 58174, 58177, 58191, 58217, 58250, 58253, 58277, 58331, 58404, 58455, 58460, 58490, 58491, 58544, 58549, 58552, 58554,
        58563, 58576, 58600, 58628, 58672, 58712, 58771, 58773, 58885, 59019, 59127, 59128, 59136, 59170, 59190, 59200, 59269, 59297, 59344, 59379,
        59399, 59407, 59420, 59455, 59511, 59535, 59549, 59579, 59582, 59623, 59743, 59764, 59767, 59790, 59815, 59823, 59838, 59896, 59900, 59925,
        59971, 59989, 60021, 60068, 60071, 60082, 60116, 60120, 60132, 60161, 60190, 60192, 60249, 60296, 60314, 60348, 60369, 60402, 60453, 60538,
        60571, 60582, 60599, 60603, 60618, 60716, 60750, 60774, 60792, 60858, 60989, 61035, 61072, 61098, 61107, 61113, 61175, 61217, 61229, 61289,
        61297, 61307, 61326, 61365, 61384, 61399, 61435, 61468, 61515, 61519, 61533, 61561, 61573, 61617, 61627, 61674, 61677, 61729, 61987, 62048,
        62197, 62283, 62304, 62341, 62402, 62480, 62487, 62537, 62574, 62602, 62652, 62717, 62739, 62799, 62815, 62838, 62884, 62889, 62903, 63014,
        63026, 63041, 63046, 63059, 63102, 63130, 63131, 63192, 63203, 63211, 63257, 63282, 63326, 63394, 63415, 63426, 63448, 63465, 63753, 63800,
        63812, 63814, 63825, 63844, 63935, 64009, 64049, 64073, 64088, 64109, 64136, 64200, 64227, 64272, 64317, 64326, 64365, 64367, 64373, 64466,
        64484, 64526, 64530, 64532, 64567, 64621, 64628, 64689, 64698, 64701, 64772, 64777, 64781, 64789, 64847, 64937, 64996, 65084, 65135, 65181,
        65190, 65255, 65306, 65353, 65395, 65423, 65427, 65451, 65487, 65536, 65543, 65604, 65639, 65712, 65745, 65772, 65778, 65855, 65934, 65949,
        66015, 66044, 66074, 66123, 66153, 66171, 66263, 66334, 66391, 66441, 66465, 66479, 66502, 66539, 66566, 66619, 66645, 66756, 66831, 66832,
        66857, 66863, 66866, 66884, 66888, 66975, 67045, 67055, 67070, 67103, 67106, 67134, 67154, 67156, 67157, 67200, 67234, 67244, 67275, 67354,
        67399, 67407, 67413, 67440, 67443, 67454, 67493, 67563, 67587, 67621, 67655, 67688, 67730, 67756, 67832, 67879, 67944, 67954, 67960, 67974,
        68053, 68116, 68136, 68148, 68175, 68274, 68278, 68312, 68360, 68397, 68453, 68464, 68505, 68514, 68522, 68536, 68602, 68637, 68703, 68858,
        68864, 68879, 68963, 68965, 69035, 69139, 69149, 69191, 69207, 69241, 69258, 69283, 69347, 69362, 69363, 69425, 69432, 69440, 69461, 69479,
        69488, 69531, 69613, 69625, 69638, 69690, 69757, 69764, 69780, 69816, 69849, 69890, 69968, 69969, 69977, 70040, 70062, 70100, 70108, 70113,
        70116, 70138, 70177, 70222, 70228, 70245, 70326, 70647, 70666, 70721, 70728, 70773, 70782, 70789, 70838, 70857, 70959, 70987, 71025, 71040,
        71072, 71077, 71084, 71112, 71189, 71214, 71224, 71246, 71270, 71272, 71313, 71318, 71320, 71324, 71351, 71372, 71375, 71403, 71534, 71564,
        71565, 71614, 71625, 71693, 71708, 71761, 71802, 71824, 71870, 71942, 71947, 71963, 71984, 71988, 72037, 72065, 72118, 72127, 72140, 72153,
        72155, 72163, 72175, 72186, 72231, 72367, 72406, 72451, 72457, 72483, 72491, 72507, 72525, 72534, 72545, 72551, 72554, 72561, 72578, 72622,
        72731, 72789, 72800, 72812, 72819, 72913, 73041, 73044, 73046, 73061, 73075, 73097, 73106, 73146, 73147, 73291, 73292, 73294, 73324, 73374,
        73514, 73542, 73594, 73652, 73698, 73699, 73719, 73754, 73759, 73775, 73784, 73810, 73836, 73844, 73885, 73894, 73947, 73967, 73972, 74062,
        74075, 74103, 74107, 74146, 74159, 74205, 74277, 74293, 74306, 74328, 74345, 74413, 74501, 74518, 74589, 74626, 74648, 74650, 74652, 74655,
        74729, 74773, 74805, 74947, 74970, 74977, 75074, 75077, 75121, 75210, 75364, 75381, 75397, 75405, 75414, 75428, 75540, 75559, 75580, 75661,
        75681, 75687, 75730, 75740, 75758, 75812, 75823, 75831, 75858, 75874, 75894, 75901, 75928, 75945, 75956, 76044, 76045, 76063, 76069, 76112,
        76198, 76274, 76324, 76325, 76333, 76334, 76345, 76402, 76406, 76430, 76446, 76555, 76563, 76575, 76594, 76595, 76673, 76696, 76730, 76742,
        76762, 76773, 76796, 76852, 76882, 76899, 76907, 76915, 76929, 76966, 77004, 77038, 77052, 77110, 77148, 77192, 77203, 77214, 77240, 77247,
        77252, 77283, 77301, 77346, 77386, 77398, 77406, 77498, 77593, 77610, 77613, 77633, 77704, 77780, 77781, 77803, 77810, 77816, 77846, 77990,
        78006, 78043, 78062, 78072, 78092, 78133, 78162, 78180, 78224, 78258, 78277, 78312, 78376, 78390, 78436, 78448, 78543, 78639, 78665, 78707,
        78733, 78735, 78755, 78762, 78785, 78870, 78895, 78919, 78954, 78977, 79020, 79033, 79038, 79052, 79053, 79067, 79168, 79202, 79219, 79221,
        79227, 79232, 79243, 79291, 79326, 79353, 79425, 79545, 79550, 79686, 79711, 79744, 79856, 79894, 79928, 79942, 79961, 80014, 80033, 80106,
        80176, 80183, 80191, 80220, 80277, 80293, 80316, 80320, 80333, 80396, 80445, 80476, 80482, 80501, 80526, 80529, 80552, 80557, 80609, 80701,
        80841, 80865, 80964, 80969, 80972, 81004, 81030, 81065, 81095, 81293, 81331, 81405, 81420, 81423, 81453, 81456, 81457, 81571, 81619, 81713,
        81725, 81773, 81778, 81785, 81794, 81840, 81882, 81895, 81897, 81904, 81989, 82039, 82047, 82051, 82139, 82168, 82231, 82272, 82334, 82382,
        82459, 82538, 82638, 82639, 82645, 82837, 82844, 82854, 82969, 82972, 83053, 83059, 83070, 83120, 83155, 83157, 83161, 83168, 83180, 83259,
        83264, 83269, 83281, 83292, 83326, 83378, 83404, 83492, 83516, 83561, 83572, 83584, 83601, 83661, 83666, 83675, 83711, 83712, 83745, 83753,
        83756, 83849, 83888, 83930, 83959, 83963, 84059, 84127, 84166, 84218, 84224, 84243, 84332, 84364, 84378, 84389, 84404, 84418, 84466, 84535,
        84543, 84548, 84553, 84572, 84597, 84603, 84618, 84634, 84670, 84671, 84698, 84733, 84755, 84791, 84835, 84843, 84915, 84938, 84947, 84979,
        85011, 85026, 85041, 85077, 85115, 85122, 85188, 85221, 85322, 85358, 85362, 85429, 85436, 85522, 85548, 85688, 85746, 85760, 85764, 85817,
        85869, 85942, 85979, 85989, 86052, 86056, 86063, 86088, 86109, 86193, 86249, 86267, 86308, 86406, 86425, 86434, 86457, 86458, 86498, 86554,
        86563, 86589, 86600, 86662, 86683, 86684, 86784, 86966, 87031, 87065, 87161, 87164, 87193, 87196, 87233, 87241, 87248, 87252, 87260, 87283,
        87293, 87400, 87453, 87465, 87484, 87504, 87561, 87567, 87601, 87614, 87712, 87750, 87753, 87788, 87804, 87831, 87894, 87918, 87971, 87980,
        88015, 88037, 88057, 88066, 88128, 88145, 88246, 88285, 88305, 88492, 88506, 88541, 88545, 88627, 88628, 88641, 88667, 88668, 88711, 88719,
        88767, 88769, 88776, 88810, 88820, 88827, 88832, 88838, 88841, 88851, 88864, 88903, 88973, 88997, 88999, 89038, 89053, 89077, 89080, 89103,
        89182, 89197, 89215, 89219, 89222, 89261, 89318, 89451, 89491, 89611, 89630, 89723, 89753, 89819, 89833, 89853, 89925, 89934, 89937, 89971,
        89997, 90033, 90035, 90060, 90141, 90166, 90168, 90239, 90263, 90276, 90307, 90362, 90441, 90480, 90541, 90577, 90587, 90592, 90641, 90684,
        90695, 90791, 90795, 90801, 90828, 90845, 90862, 90863, 90929, 90951, 91085, 91110, 91177, 91179, 91215, 91224, 91286, 91443, 91444, 91589,
        91591, 91605, 91679, 91753, 91767, 91781, 91783, 91803, 91805, 91839, 91840, 91846, 91871, 91876, 91885, 91915, 91923, 91950, 91952, 91977,
        92031, 92046, 92085, 92146, 92149, 92153, 92157, 92166, 92201, 92211, 92322, 92353, 92369, 92444, 92448, 92498, 92510, 92580, 92611, 92623,
        92667, 92681, 92690, 92707, 92708, 92717, 92738, 92837, 92886, 92921, 92929, 92978, 93021, 93047, 93049, 93075, 93078, 93080, 93082, 93141,
        93147, 93157, 93203, 93240, 93244, 93255, 93285, 93289, 93292, 93312, 93322, 93336, 93351, 93392, 93405, 93459, 93461, 93532, 93554, 93588,
        93594, 93603, 93618, 93709, 93736, 93782, 93792, 93828, 93838, 93935, 93980, 93996, 93998, 94004, 94063, 94086, 94101, 94157, 94257, 94278,
        94315, 94334, 94344, 94345, 94362, 94380, 94387, 94431, 94503, 94672, 94678, 94731, 94768, 94776, 94795, 94821, 94909, 94977, 95045, 95218,
        95248, 95298, 95314, 95371, 95429, 95467, 95488, 95503, 95524, 95545, 95629, 95661, 95664, 95683, 95730, 95743, 95803, 95806, 95808, 95834,
        95842, 95855, 95874, 95887, 95903, 95917, 95926, 95936, 95942, 96062, 96082, 96134, 96171, 96197, 96223, 96234, 96243, 96257, 96263, 96266,
        96306, 96310, 96361, 96388, 96416, 96425, 96482, 96490, 96493, 96564, 96605, 96615, 96654, 96659, 96666, 96721, 96788, 96845, 96868, 96895,
        96937, 96960, 96970, 96988, 97040, 97047, 97081, 97097, 97100, 97201, 97210, 97347, 97431, 97521, 97558, 97569, 97577, 97578, 97609, 97610,
        97643, 97665, 97720, 97752, 97755, 97769, 97786, 97842, 97933, 97934, 97952, 97969, 98013, 98033, 98102, 98110, 98162, 98170, 98209, 98226,
        98273, 98288, 98297, 98323, 98357, 98402, 98439, 98449, 98505, 98506, 98599, 98683, 98722, 98759, 98840, 98843, 98974, 98983, 99005, 99016,
        99025, 99069, 99178, 99216, 99290, 99305, 99368, 99397, 99464, 99517, 99540, 99616, 99658, 99689, 99709, 99716, 99748, 99754, 99757, 99806,
        99828, 99845, 99900, 99931, 99949, 99972, 99976
    ];

    private readonly List<int> SEEDS2 = [
        78, 101, 177, 191, 207, 249, 295, 335, 398, 574, 575, 578, 651, 655, 671, 681, 689, 718, 791,
        932, 1026, 1031, 1078, 1085, 1132, 1137, 1143, 1144, 1158, 1265, 1272, 1274, 1284, 1324, 1337, 1350, 1357, 1430, 1441,
        1444, 1546, 1558, 1566, 1603, 1627, 1657, 1713, 1790, 1811, 1817, 1855, 1927, 1938, 1986, 2006, 2057, 2103, 2112, 2159,
        2352, 2371, 2426, 2522, 2523, 2725, 2749, 2841, 2929, 2936, 2979, 3023, 3109, 3190, 3226, 3261, 3277, 3281, 3313, 3314,
        3327, 3331, 3406, 3409, 3421, 3428, 3439, 3470, 3607, 3609, 3621, 3697, 3772, 3813, 3825, 3863, 3949, 3986, 4022, 4037,
        4055, 4068, 4081, 4167, 4221, 4228, 4244, 4262, 4273, 4313, 4377, 4391, 4393, 4424, 4540, 4640, 4649, 4673, 4700, 4753,
        4777, 4842, 4847, 4900, 4911, 4957, 5007, 5042, 5081, 5162, 5206, 5215, 5230, 5244, 5306, 5327, 5328, 5349, 5428, 5497,
        5567, 5607, 5712, 5874, 5904, 5981, 6003, 6022, 6027, 6071, 6076, 6174, 6201, 6250, 6278, 6292, 6368, 6443, 6501, 6508,
        6511, 6564, 6677, 6762, 6775, 6903, 6948, 7078, 7136, 7180, 7215, 7286, 7303, 7311, 7323, 7329, 7402, 7408, 7422, 7475,
        7504, 7506, 7567, 7595, 7620, 7621, 7635, 7651, 7664, 7683, 7715, 7884, 7963, 8011, 8036, 8043, 8080, 8089, 8094, 8098,
        8116, 8155, 8233, 8249, 8407, 8557, 8576, 8577, 8593, 8621, 8727, 8737, 8799, 8853, 8929, 9011, 9088, 9135, 9159, 9256,
        9271, 9313, 9358, 9522, 9556, 9557, 9575, 9585, 9708, 9844, 9881, 9986, 10031, 10039, 10056, 10166, 10172, 10252, 10260, 10272,
        10307, 10327, 10383, 10397, 10399, 10408, 10416, 10424, 10428, 10434, 10454, 10519, 10541, 10553, 10617, 10623, 10671, 10672, 10812, 10850,
        10895, 11026, 11042, 11054, 11062, 11095, 11098, 11116, 11135, 11241, 11390, 11421, 11460, 11464, 11477, 11482, 11498, 11510, 11530, 11537,
        11570, 11623, 11649, 11676, 11755, 11780, 11840, 11870, 11874, 11883, 11893, 11952, 11997, 12028, 12201, 12279, 12311, 12360, 12370, 12459,
        12495, 12507, 12560, 12627, 12641, 12797, 12853, 12893, 12935, 12947, 13066, 13071, 13093, 13122, 13147, 13161, 13268, 13273, 13320, 13353,
        13377, 13384, 13394, 13405, 13436, 13439, 13462, 13515, 13572, 13631, 13653, 13710, 13741, 13774, 13796, 13864, 13875, 13967, 13971, 13986,
        14063, 14069, 14071, 14113, 14142, 14174, 14213, 14232, 14259, 14275, 14332, 14361, 14382, 14438, 14439, 14481, 14491, 14510, 14514, 14559,
        14570, 14651, 14699, 14737, 14828, 14858, 14868, 14882, 14883, 14976, 14982, 14984, 15016, 15055, 15110, 15117, 15166, 15174, 15222, 15269,
        15276, 15373, 15424, 15497, 15502, 15595, 15597, 15608, 15660, 15687, 15765, 15797, 15815, 15903, 15994, 16004, 16021, 16059, 16081, 16086,
        16101, 16114, 16115, 16212, 16252, 16257, 16309, 16352, 16401, 16420, 16423, 16431, 16482, 16521, 16535, 16603, 16741, 16747, 16840, 16850,
        16856, 16877, 16925, 16960, 16967, 17001, 17092, 17169, 17206, 17233, 17257, 17425, 17508, 17528, 17535, 17565, 17613, 17628, 17759, 17828,
        17831, 17843, 17844, 17860, 17873, 17891, 18029, 18032, 18102, 18140, 18164, 18194, 18258, 18343, 18356, 18431, 18484, 18523, 18530, 18578,
        18583, 18605, 18621, 18629, 18645, 18877, 18932, 18936, 18968, 18975, 19037, 19038, 19041, 19097, 19099, 19132, 19134, 19240, 19403, 19407,
        19422, 19470, 19472, 19541, 19589, 19658, 19664, 19666, 19859, 19878, 19903, 19922, 19955, 19982, 19998, 20049, 20132, 20141, 20165, 20195,
        20206, 20233, 20236, 20254, 20321, 20571, 20625, 20628, 20639, 20664, 20687, 20726, 20810, 20821, 20827, 20874, 20900, 20902, 20909, 21004,
        21028, 21082, 21083, 21119, 21156, 21241, 21260, 21286, 21387, 21413, 21472, 21489, 21492, 21505, 21636, 21818, 21828, 21874, 21927, 21944,
        21949, 21977, 22011, 22064, 22099, 22164, 22227, 22257, 22278, 22284, 22320, 22381, 22395, 22463, 22565, 22575, 22599, 22629, 22655, 22675,
        22696, 22702, 22723, 22754, 22786, 22805, 22948, 22966, 22978, 23023, 23182, 23183, 23185, 23204, 23254, 23316, 23322, 23325, 23335, 23408,
        23419, 23431, 23442, 23546, 23560, 23583, 23584, 23697, 23708, 23760, 23787, 23878, 23918, 24013, 24026, 24039, 24072, 24195, 24210, 24243,
        24352, 24405, 24413, 24484, 24533, 24602, 24633, 24668, 24709, 24722, 24829, 24841, 24860, 24898, 24906, 24934, 24964, 25050, 25054, 25065,
        25110, 25160, 25207, 25348, 25360, 25362, 25422, 25451, 25470, 25489, 25518, 25586, 25652, 25663, 25705, 25717, 25750, 25773, 25818, 25828,
        25831, 25841, 25870, 25966, 25973, 26008, 26015, 26044, 26068, 26072, 26079, 26165, 26294, 26357, 26503, 26559, 26605, 26606, 26664, 26690,
        26764, 26835, 26967, 26980, 26992, 27080, 27086, 27099, 27176, 27309, 27316, 27416, 27494, 27524, 27554, 27629, 27638, 27645, 27708, 27737,
        27754, 27766, 27819, 27826, 27903, 27979, 27985, 28105, 28174, 28226, 28265, 28278, 28305, 28405, 28524, 28532, 28533, 28617, 28901, 28925,
        28956, 29008, 29016, 29054, 29135, 29193, 29268, 29289, 29343, 29428, 29436, 29444, 29493, 29527, 29545, 29571, 29607, 29668, 29688, 29715,
        29741, 29772, 29783, 29792, 29799, 29948, 29965, 29971, 29983, 30049, 30099, 30105, 30125, 30162, 30220, 30256, 30294, 30315, 30321, 30322,
        30350, 30415, 30469, 30477, 30487, 30491, 30509, 30689, 30733, 30763, 30770, 30771, 30850, 30867, 30902, 30909, 30958, 31054, 31100, 31162,
        31172, 31225, 31242, 31258, 31335, 31405, 31432, 31441, 31442, 31458, 31469, 31475, 31498, 31541, 31605, 31682, 31696, 31826, 31909, 31912,
        31940, 31946, 31947, 31967, 32010, 32038, 32077, 32097, 32143, 32185, 32281, 32284, 32378, 32402, 32414, 32420, 32496, 32509, 32538, 32579,
        32638, 32643, 32664, 32731, 32752, 32854, 32858, 32892, 32894, 32933, 33023, 33087, 33181, 33211, 33217, 33375, 33409, 33610, 33625, 33627,
        33645, 33674, 33677, 33695, 33746, 33826, 33966, 33982, 33994, 34010, 34095, 34112, 34120, 34139, 34208, 34286, 34450, 34481, 34505, 34581,
        34585, 34688, 34742, 34760, 34793, 34798, 34829, 34858, 34938, 35015, 35047, 35083, 35102, 35114, 35122, 35151, 35165, 35216, 35223, 35303,
        35339, 35383, 35393, 35402, 35440, 35537, 35570, 35588, 35708, 35715, 35724, 35849, 35868, 35892, 36075, 36090, 36096, 36136, 36169, 36250,
        36448, 36508, 36574, 36620, 36701, 36729, 36759, 36795, 36799, 36868, 36919, 36995, 37021, 37022, 37033, 37057, 37085, 37141, 37152, 37211,
        37226, 37235, 37318, 37394, 37418, 37427, 37600, 37604, 37607, 37636, 37701, 37714, 37744, 37747, 37793, 37807, 37812, 37924, 37979, 37997,
        38159, 38160, 38170, 38217, 38247, 38268, 38315, 38349, 38370, 38384, 38507, 38655, 38660, 38663, 38670, 38675, 38702, 38707, 38766, 38774,
        38852, 38945, 38963, 38964, 39006, 39014, 39018, 39020, 39026, 39036, 39042, 39078, 39097, 39103, 39143, 39381, 39406, 39407, 39452, 39468,
        39493, 39525, 39621, 39701, 39782, 39788, 39804, 39805, 39812, 39835, 39873, 39885, 39894, 39896, 39935, 40025, 40048, 40102, 40103, 40125,
        40160, 40210, 40213, 40266, 40344, 40359, 40373, 40453, 40462, 40566, 40575, 40638, 40660, 40671, 40684, 40697, 40702, 40778, 40820, 40840,
        40917, 40920, 40964, 40971, 40990, 40992, 41012, 41052, 41098, 41221, 41285, 41317, 41319, 41360, 41462, 41497, 41505, 41555, 41591, 41636,
        41696, 41796, 41809, 41843, 41892, 41981, 41987, 42062, 42110, 42122, 42131, 42153, 42253, 42255, 42273, 42334, 42383, 42387, 42466, 42494,
        42523, 42528, 42561, 42587, 42663, 42664, 42673, 42685, 42797, 42810, 42820, 42857, 42861, 42889, 42942, 43019, 43040, 43067, 43107, 43108,
        43122, 43136, 43263, 43305, 43385, 43429, 43512, 43579, 43661, 43682, 43738, 43922, 43956, 44010, 44018, 44020, 44038, 44063, 44082, 44151,
        44152, 44241, 44325, 44335, 44336, 44352, 44396, 44442, 44513, 44534, 44611, 44654, 44663, 44686, 44722, 44724, 44768, 44781, 44797, 44848,
        44884, 44905, 44969, 44975, 44987, 44993, 45012, 45019, 45085, 45126, 45133, 45135, 45199, 45323, 45365, 45433, 45481, 45485, 45502, 45601,
        45644, 45675, 45721, 45744, 45791, 45805, 45810, 45844, 45941, 45953, 45966, 45973, 46095, 46227, 46271, 46313, 46336, 46377, 46380, 46387,
        46422, 46426, 46470, 46555, 46595, 46607, 46624, 46683, 46710, 46742, 46847, 46854, 46880, 46917, 47036, 47049, 47110, 47124, 47129, 47200,
        47225, 47308, 47314, 47365, 47382, 47392, 47410, 47416, 47427, 47463, 47574, 47594, 47609, 47714, 47740, 47747, 47761, 47927, 48028, 48104,
        48145, 48268, 48310, 48362, 48384, 48444, 48477, 48479, 48549, 48616, 48641, 48658, 48673, 48675, 48687, 48698, 48910, 48968, 48974, 48975,
        49010, 49029, 49037, 49083, 49091, 49100, 49122, 49136, 49161, 49186, 49242, 49276, 49290, 49295, 49357, 49368, 49371, 49373, 49474, 49505,
        49582, 49666, 49703, 49774, 49877, 49880, 49905, 49937, 49995, 50069, 50180, 50349, 50355, 50454, 50461, 50519, 50625, 50644, 50656, 50676,
        50697, 50727, 50799, 50845, 50867, 50898, 50908, 50918, 50939, 50954, 50985, 51115, 51133, 51149, 51214, 51240, 51257, 51363, 51415, 51453,
        51463, 51493, 51513, 51544, 51646, 51655, 51712, 51743, 51752, 51778, 51843, 51886, 51965, 52026, 52028, 52116, 52147, 52291, 52349, 52365,
        52395, 52410, 52481, 52494, 52576, 52798, 52813, 52855, 52887, 52893, 53029, 53096, 53125, 53131, 53255, 53265, 53291, 53341, 53394, 53401,
        53416, 53451, 53470, 53507, 53600, 53732, 53742, 53773, 53825, 53867, 53923, 53929, 53952, 54006, 54009, 54137, 54151, 54204, 54238, 54271,
        54307, 54323, 54336, 54431, 54474, 54480, 54485, 54519, 54531, 54544, 54617, 54630, 54632, 54688, 54778, 54850, 54898, 54930, 54936, 54962,
        55108, 55135, 55221, 55242, 55334, 55337, 55365, 55388, 55431, 55480, 55519, 55629, 55643, 55683, 55715, 55791, 55826, 55841, 55847, 55850,
        55905, 55918, 55955, 55964, 56028, 56040, 56066, 56225, 56260, 56303, 56359, 56372, 56400, 56402, 56580, 56588, 56606, 56750, 56772, 56802,
        56807, 56812, 56822, 56909, 56940, 56974, 57007, 57051, 57062, 57079, 57126, 57133, 57177, 57354, 57387, 57390, 57398, 57468, 57475, 57481,
        57496, 57655, 57701, 57741, 57748, 57808, 57825, 57842, 57871, 57912, 58011, 58017, 58026, 58053, 58071, 58081, 58087, 58102, 58144, 58148,
        58164, 58215, 58234, 58294, 58319, 58323, 58364, 58528, 58532, 58544, 58549, 58552, 58632, 58681, 58724, 58774, 58784, 58790, 58874, 58929,
        58932, 58998, 59065, 59109, 59128, 59135, 59337, 59358, 59391, 59393, 59545, 59548, 59575, 59618, 59636, 59703, 59899, 59938, 59949, 59963,
        59970, 59971, 60019, 60067, 60091, 60098, 60139, 60200, 60244, 60246, 60313, 60460, 60502, 60525, 60527, 60582, 60642, 60708, 60710, 60711,
        60763, 60780, 60788, 60810, 60851, 60948, 61034, 61035, 61071, 61101, 61166, 61267, 61303, 61377, 61398, 61408, 61411, 61467, 61473, 61492,
        61674, 61700, 61715, 61821, 61844, 61860, 61861, 61904, 61908, 61928, 61934, 61962, 61965, 62041, 62073, 62077, 62078, 62103, 62158, 62197,
        62288, 62573, 62621, 62666, 62686, 62723, 62787, 62798, 62845, 62859, 62882, 62888, 62912, 62915, 63000, 63055, 63098, 63104, 63142, 63187,
        63209, 63238, 63258, 63260, 63325, 63328, 63346, 63362, 63379, 63404, 63591, 63620, 63625, 63660, 63701, 63756, 63761, 63765, 63807, 63829,
        63907, 63920, 63961, 63983, 64001, 64026, 64028, 64052, 64073, 64129, 64149, 64186, 64294, 64456, 64463, 64466, 64489, 64494, 64533, 64642,
        64737, 64767, 64820, 64835, 64844, 64858, 64862, 64887, 64901, 64912, 64968, 65017, 65147, 65167, 65178, 65195, 65289, 65329, 65347, 65366,
        65405, 65412, 65549, 65587, 65589, 65642, 65706, 65787, 65791, 65800, 65844, 65911, 65957, 66033, 66111, 66115, 66137, 66239, 66242, 66293,
        66317, 66406, 66432, 66528, 66532, 66653, 66663, 66672, 66688, 66698, 66798, 66836, 66895, 66919, 66933, 67005, 67047, 67075, 67083, 67100,
        67198, 67223, 67249, 67363, 67558, 67582, 67626, 67648, 67656, 67732, 67804, 67821, 67824, 67845, 67914, 67953, 67978, 67982, 68067, 68117,
        68185, 68235, 68305, 68311, 68346, 68381, 68402, 68441, 68454, 68459, 68474, 68565, 68583, 68586, 68624, 68657, 68661, 68664, 68705, 68780,
        68873, 68888, 68921, 69023, 69083, 69162, 69234, 69239, 69272, 69288, 69329, 69332, 69392, 69480, 69563, 69718, 69842, 69848, 69864, 69875,
        69885, 69954, 69959, 69983, 70020, 70039, 70112, 70166, 70191, 70207, 70226, 70270, 70278, 70282, 70325, 70384, 70573, 70676, 70709, 70726,
        70750, 70757, 70790, 70818, 70834, 70863, 70885, 70927, 70959, 70973, 71012, 71122, 71128, 71146, 71147, 71212, 71397, 71407, 71408, 71423,
        71453, 71462, 71562, 71604, 71619, 71656, 71683, 71784, 71806, 71854, 71855, 71933, 71963, 71969, 71993, 72078, 72098, 72101, 72114, 72155,
        72194, 72208, 72301, 72392, 72400, 72418, 72521, 72547, 72564, 72567, 72595, 72597, 72612, 72644, 72667, 72685, 72737, 72914, 72943, 72972,
        73034, 73060, 73135, 73161, 73183, 73213, 73232, 73248, 73253, 73261, 73263, 73335, 73426, 73427, 73432, 73445, 73593, 73603, 73664, 73674,
        73693, 73703, 73712, 73718, 73790, 73793, 73797, 73830, 73874, 73890, 73926, 73942, 74015, 74032, 74046, 74066, 74109, 74125, 74150, 74167,
        74169, 74537, 74569, 74613, 74618, 74628, 74716, 74782, 74843, 74867, 74938, 74960, 75008, 75029, 75118, 75133, 75173, 75197, 75290, 75302,
        75327, 75345, 75395, 75401, 75405, 75437, 75462, 75468, 75511, 75603, 75677, 75694, 75704, 75706, 75721, 75751, 75759, 75761, 75837, 75842,
        75853, 75927, 75933, 75952, 76086, 76141, 76143, 76147, 76166, 76202, 76273, 76278, 76407, 76421, 76463, 76537, 76550, 76677, 76714, 76864,
        76903, 76921, 76922, 76945, 76946, 76964, 76969, 76971, 77074, 77124, 77149, 77173, 77190, 77191, 77227, 77310, 77330, 77396, 77405, 77475,
        77496, 77618, 77626, 77667, 77698, 77819, 77904, 77997, 78000, 78002, 78034, 78097, 78121, 78207, 78272, 78292, 78293, 78344, 78354, 78383,
        78454, 78787, 78826, 78842, 78952, 78987, 79046, 79297, 79321, 79373, 79466, 79476, 79517, 79519, 79623, 79676, 79726, 79854, 79921, 79948,
        80041, 80103, 80118, 80126, 80187, 80238, 80273, 80322, 80335, 80392, 80413, 80487, 80489, 80533, 80535, 80582, 80607, 80696, 80943, 80948,
        80991, 81011, 81022, 81082, 81114, 81200, 81219, 81309, 81407, 81425, 81469, 81542, 81569, 81591, 81662, 81681, 81685, 81768, 81796, 81803,
        81892, 81900, 81910, 81918, 81942, 81945, 81959, 81964, 81969, 81972, 82037, 82148, 82187, 82250, 82283, 82395, 82405, 82434, 82449, 82450,
        82461, 82463, 82480, 82496, 82514, 82530, 82615, 82696, 82702, 82859, 82978, 83116, 83209, 83235, 83320, 83357, 83427, 83439, 83448, 83480,
        83505, 83509, 83539, 83552, 83563, 83693, 83696, 83701, 83741, 83749, 83778, 83837, 83885, 83906, 83919, 83933, 83940, 83953, 83984, 83987,
        84111, 84158, 84160, 84186, 84239, 84326, 84398, 84412, 84421, 84434, 84441, 84447, 84471, 84479, 84496, 84705, 84778, 84800, 84816, 84861,
        84909, 84930, 84971, 85028, 85056, 85059, 85061, 85157, 85176, 85229, 85242, 85249, 85281, 85318, 85375, 85443, 85470, 85503, 85525, 85557,
        85566, 85801, 85846, 85853, 85873, 85892, 85900, 85903, 85905, 85920, 85967, 85990, 86012, 86017, 86070, 86086, 86090, 86158, 86255, 86305,
        86309, 86405, 86459, 86505, 86564, 86621, 86626, 86650, 86711, 86729, 86733, 86735, 86752, 86766, 86798, 86803, 86825, 86899, 87001, 87015,
        87039, 87100, 87158, 87249, 87312, 87315, 87335, 87363, 87395, 87474, 87527, 87531, 87599, 87642, 87789, 87863, 87898, 87974, 88080, 88127,
        88307, 88336, 88346, 88411, 88419, 88449, 88617, 88703, 88725, 88771, 88867, 88927, 88937, 88946, 89038, 89056, 89086, 89102, 89120, 89129,
        89134, 89187, 89189, 89231, 89330, 89343, 89405, 89409, 89442, 89478, 89531, 89554, 89617, 89623, 89650, 89753, 89782, 89823, 89828, 89861,
        89885, 89966, 90030, 90204, 90410, 90424, 90439, 90449, 90456, 90497, 90538, 90560, 90576, 90868, 90871, 90887, 90897, 90984, 91008, 91346,
        91348, 91358, 91464, 91581, 91637, 91645, 91745, 91830, 91850, 91887, 91888, 91942, 91949, 91985, 92057, 92073, 92099, 92224, 92284, 92346,
        92349, 92386, 92414, 92421, 92524, 92551, 92724, 92775, 92776, 92805, 92827, 92842, 92878, 93008, 93024, 93105, 93109, 93118, 93139, 93164,
        93255, 93359, 93452, 93576, 93604, 93637, 93651, 93691, 93736, 93792, 93854, 93996, 94038, 94073, 94074, 94080, 94086, 94120, 94251, 94289,
        94309, 94362, 94363, 94376, 94393, 94415, 94424, 94479, 94521, 94543, 94578, 94592, 94641, 94665, 94678, 94696, 94839, 94931, 95050, 95077,
        95100, 95115, 95237, 95262, 95268, 95400, 95453, 95460, 95470, 95473, 95569, 95618, 95682, 95744, 95801, 95860, 95897, 95939, 96003, 96048,
        96063, 96087, 96093, 96097, 96144, 96193, 96202, 96280, 96307, 96310, 96322, 96379, 96407, 96466, 96509, 96515, 96541, 96593, 96624, 96665,
        96696, 96698, 96721, 96759, 96774, 96800, 96824, 96860, 96869, 96884, 96908, 97001, 97006, 97057, 97092, 97095, 97118, 97119, 97167, 97227,
        97265, 97266, 97296, 97346, 97377, 97418, 97491, 97555, 97570, 97668, 97687, 97732, 97772, 97893, 97898, 97922, 97982, 98054, 98074, 98110,
        98272, 98314, 98420, 98457, 98540, 98624, 98637, 98640, 98698, 98704, 98712, 98842, 98868, 98939, 98961, 99028, 99035, 99139, 99140, 99182,
        99213, 99231, 99261, 99282, 99333, 99420, 99437, 99439, 99448, 99624, 99640, 99719, 99786, 99793, 99859, 99918, 99938
    ];

    public UI(Menu.Menu menu, MenuObject owner, Vector2 pos, Vector2 size) : base(menu, owner, pos, size)
    {
        wrapper = new MenuTabWrapper(menu, this);
        subObjects.Add(wrapper);

        warp = new SimpleButton(menu, this, "WARP", "warp", new Vector2(145f, RwLogger.screenDims.y - 135f), new Vector2(110f, 30f));
        subObjects.Add(warp);
    }

    public override void Singal(MenuObject sender, string message)
    {
        base.Singal(sender, message);
        if (message == "warp")
        {
            Task.Run(() =>
            {
                RainWorldGame _game = (RainWorldGame)RwLogger.game.processManager.currentMainLoop;
                var room = _game.Players[0].Room;
                var world = room.world;
                var worldName = world.name;
                int warps = world.game.GetStorySession.saveState.miscWorldSaveData.numberOfWarpPointsGenerated;
                int badWarps = world.game.GetStorySession.saveState.miscWorldSaveData.numberOfBadWarpsGenerated;
                var discoveredPoints = new Dictionary<string, string>(world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints);
                List<string> roomsSealedByVoidWeaverCopy = [.. world.game.GetStorySession.saveState.miscWorldSaveData.roomsSealedByVoidWeaver];
                List<string> roomsSealedByWeaverAbilityCopy = [.. world.game.GetStorySession.saveState.miscWorldSaveData.roomsSealedByWeaverAbility];
                List<string> regionsInfectedBySentientRotCopy = [.. world.game.GetStorySession.saveState.miscWorldSaveData.regionsInfectedBySentientRot];
                List<string> regionLoadStringsCopy = [.. world.game.GetStorySession.saveState.regionLoadStrings];

                var chooseDynamicWarpTarget = AppDomain.CurrentDomain.GetAssemblies()
                    .SelectMany(x => x.GetTypes())
                    .SelectMany(x => x.GetMethods(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static))
                    .Where(x => x.Name == "ChooseDynamicWarpTarget").FirstOrDefault();

                if (chooseDynamicWarpTarget == null)
                {
                    RwLogger.logger.LogInfo("ChooseDynamicWarpTarget method not found via reflection.");
                    return;
                }

                // foreach (var warp in world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints)
                // {
                //     RwLogger.logger.LogInfo($"Discovered warp point: {warp.Key} -> {warp.Value}");
                // }
                // foreach (var connection in world.game.GetStorySession.saveState.regionLoadStrings)
                // {
                //     RwLogger.logger.LogInfo($"Portal {connection}");
                // }
                // foreach (RegionState state in world.game.GetStorySession.saveState.regionStates)
                // {
                //     RwLogger.logger.LogInfo($"{state?.regionName}");
                // }
                // List<string> unsealedWarps = world.game.GetStorySession.saveState.RoomsWithWarpsRemainingToBeSealed(false, "");
                // foreach (var warp in unsealedWarps)
                // {
                //     RwLogger.logger.LogInfo($"Unsealed warp point: {warp}");
                // }

                // string text = world.name;
                // GetNext10Warps(world, chooseDynamicWarpTarget);
                // Reset world state cus var is a reference
                // world.game.GetStorySession.saveState.miscWorldSaveData.numberOfWarpPointsGenerated = warps;
                // world.name = worldName;
                // world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints = new Dictionary<string, string>(discoveredPoints);
                // world.game.GetStorySession.saveState.miscWorldSaveData.roomsSealedByVoidWeaver = [.. roomsSealedByVoidWeaverCopy];
                // world.game.GetStorySession.saveState.miscWorldSaveData.roomsSealedByWeaverAbility = [.. roomsSealedByWeaverAbilityCopy];

                // for (int i = 1; i < 100000; i++)
                // {
                //     RWCustom.Custom.rainWorld.progression.miscProgressionData.watcherCampaignSeed = i;
                //     HardCodedWeaverRoute(world, chooseDynamicWarpTarget, i);

                //     // Reset world state cus var is a reference
                //     world.game.GetStorySession.saveState.miscWorldSaveData.numberOfWarpPointsGenerated = warps;
                //     world.name = worldName;
                //     world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints = new Dictionary<string, string>(discoveredPoints);
                //     world.game.GetStorySession.saveState.miscWorldSaveData.roomsSealedByVoidWeaver = [.. roomsSealedByVoidWeaverCopy];
                //     world.game.GetStorySession.saveState.miscWorldSaveData.roomsSealedByWeaverAbility = [.. roomsSealedByWeaverAbilityCopy];
                // }

                // for (int i = 1; i < 100000; i++)
                // {
                //     RWCustom.Custom.rainWorld.progression.miscProgressionData.watcherCampaignSeed = i;
                //     SearchTrueEnding(world, chooseDynamicWarpTarget, i);

                //     // Reset world state cus var is a reference
                //     world.game.GetStorySession.saveState.miscWorldSaveData.numberOfWarpPointsGenerated = warps;
                //     world.game.GetStorySession.saveState.miscWorldSaveData.numberOfBadWarpsGenerated = badWarps;
                //     world.name = worldName;
                //     world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints = new Dictionary<string, string>(discoveredPoints);
                //     world.game.GetStorySession.saveState.miscWorldSaveData.roomsSealedByVoidWeaver = [.. roomsSealedByVoidWeaverCopy];
                //     world.game.GetStorySession.saveState.miscWorldSaveData.roomsSealedByWeaverAbility = [.. roomsSealedByWeaverAbilityCopy];
                //     world.game.GetStorySession.saveState.miscWorldSaveData.regionsInfectedBySentientRot = [.. regionsInfectedBySentientRotCopy];
                //     world.game.GetStorySession.saveState.regionLoadStrings = [.. regionLoadStringsCopy];
                // }

                // for (int j = 1; j < 100000; j++)
                // {
                // foreach (int j in SEEDS)
                // {
                //     RWCustom.Custom.rainWorld.progression.miscProgressionData.watcherCampaignSeed = j;

                //     GetEchoRoute(world, chooseDynamicWarpTarget, j);

                //     // Reset world state cus var is a reference
                //     world.game.GetStorySession.saveState.miscWorldSaveData.numberOfWarpPointsGenerated = warps;
                //     world.name = worldName;
                //     world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints = new Dictionary<string, string>(discoveredPoints);
                //     world.game.GetStorySession.saveState.miscWorldSaveData.roomsSealedByVoidWeaver = [.. roomsSealedByVoidWeaverCopy];
                //     world.game.GetStorySession.saveState.miscWorldSaveData.roomsSealedByWeaverAbility = [.. roomsSealedByWeaverAbilityCopy];
                // }

                // for (int j = 1; j < 100000; j++)
                // {
                foreach (int j in SEEDS)
                {
                    RWCustom.Custom.rainWorld.progression.miscProgressionData.watcherCampaignSeed = j;
                    try
                    {
                        GetFullRoute2(world, chooseDynamicWarpTarget, j);
                    }
                    catch (Exception e)
                    {
                        RwLogger.logger.LogInfo($"Exception during GetFullRoute with seed {j}: {e}");
                    }

                    // Reset world state cus var is a reference
                    world.game.GetStorySession.saveState.miscWorldSaveData.numberOfWarpPointsGenerated = warps;
                    world.name = worldName;
                    world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints = new Dictionary<string, string>(discoveredPoints);
                    world.game.GetStorySession.saveState.miscWorldSaveData.roomsSealedByVoidWeaver = [.. roomsSealedByVoidWeaverCopy];
                    world.game.GetStorySession.saveState.miscWorldSaveData.roomsSealedByWeaverAbility = [.. roomsSealedByWeaverAbilityCopy];
                }

                // GetNaturalRoute(world, chooseDynamicWarpTarget);

                // // Reset world state cus var is a reference
                // world.game.GetStorySession.saveState.miscWorldSaveData.numberOfWarpPointsGenerated = warps;
                // world.name = worldName;
                // world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints = new Dictionary<string, string>(discoveredPoints);
                // world.game.GetStorySession.saveState.miscWorldSaveData.roomsSealedByVoidWeaver = [.. roomsSealedByVoidWeaverCopy];
                // world.game.GetStorySession.saveState.miscWorldSaveData.roomsSealedByWeaverAbility = [.. roomsSealedByWeaverAbilityCopy];
            });
        }
    }

    public void GetFullRoute(World world, MethodInfo chooseDynamicWarpTarget, int j)
    {
        int testIterations = 10;
        // for (int _testIterations = 4; _testIterations < 7; _testIterations++)
        // {
        //     int testIterations = _testIterations;
        int rippleLvl = 2;
        int iterations = 20;
        // bool resetCache = false;

        string text = world.name;
        // world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints["WTDA_B01"] = "";
        // world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints["WSKA_D10"] = "";
        // RwLogger.logger.LogInfo($"Generating warps starting in room {text}");

        var neededList = new List<string>()
        {
            "WPTA_F01", "WTDB_A17", "WTDB_A15", "WTDB_A13", "WARB_J07", "WRRA_D03", "WRRA_D05",
            //"WARF_B23", "WARF_D29", "WTDA_Z08", "WTDA_Z04",
            //"WSKC_A19",
            // "WVWA_F02",
            //"WARC_C06",
            //"WRFB_B05", "WRFB_D02",
        };
        var neededList3 = new List<string>()
        { // Fetid allowed at 8 or more ripple (7 internally here)
            "WARC_C06",
        };
        var neededList4 = new List<string>()
        { // Verdant allowed at 7 or more ripple (6 internally here)
            "WVWA_F02",
        };
        var neededList2 = new List<string>()
        {
            // "WBLA_C02", "WBLA_F04",
            //"WARC_C06",
            // "WVWA_F02",
            "WARF_B23", "WARF_D29",
        };
        var warpsToBeClosed = new List<string>()
        {
            "WARF_B33", "WBLA_D03", "WTDB_A26", "WARC_F01", "WVWB_A04", "WARE_I14", "WARB_J01", "WPTA_F03", "WSKC_A23", "WTDA_Z14", "WRFB_A22", "WVWA_F03"
        };
        var laterWarps = new List<string>()
        {
            "WBLA_D03", "WVWB_A04",
            //"WARC_F01",
            //"WVWA_F03",
            "WARF_B33", "WTDA_Z14",
        };
        var laterWarps2 = new List<string>()
        {
            //"WBLA_D03", "WVWB_A04",
            "WARC_F01",
            //"WVWA_F03",
        };
        var laterWarps3 = new List<string>()
        {
            //"WBLA_D03", "WVWB_A04",
            // "WARC_F01",
            "WVWA_F03",
        };

        // Track closed warps
        HashSet<string> closedEchoWarps = [];
        HashSet<string> closedNaturalWarps = [];
        int totalWarpsNeeded = 12; // 12 echo + 7 natural
        int naturalWarpsNeed = 0;
        string finalPath = "";
        int totalWeight = 0;
        int totalDynamicWarps = 0;

        for (int i = 0; i < iterations; i++)
        {
            int dynamicWarpStreak = 0; // Count consecutive dynamic warps without finding needed rooms
            var discoveredPointsBeforeSearch = new Dictionary<string, string>(world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints);

            // Get unsealed natural warps
            List<string> unsealedWarps = world.game.GetStorySession.saveState.RoomsWithWarpsRemainingToBeSealed(false, "");
            List<string> regionNaturalWarps = [];
            string cachedText = text;
            int cachedWorldWarpsGen = world.game.GetStorySession.saveState.miscWorldSaveData.numberOfWarpPointsGenerated;
            string cachedWorldName = world.name;
            string searchPath = $"{text} -> ";

            // Check region's natural warps
            foreach (var warp in unsealedWarps)
            {
                string warpRegion = warp.ToUpperInvariant().Split('_')[0];
                if (warpRegion == text.Split('_')[0])
                {
                    regionNaturalWarps.Add(warp);
                }
            }

            var naturalWeightsForRegion = new Dictionary<string, int>();
            foreach (var natWarp in regionNaturalWarps)
            {
                var natUpper = natWarp.ToUpperInvariant();
                if (natUpper.Split('_')[0] != text.Split('_')[0].ToUpperInvariant()) continue;

                string key = $"{text.ToUpperInvariant()}|{natUpper}";
                // RwLogger.logger.LogInfo($"Checking natural warp weight for region key {key}");
                if (warpToPortalWeights.TryGetValue(key, out int weight))
                {
                    naturalWeightsForRegion[key] = weight;
                }
                else if (i == 0) // For now just fallback for the first warp from weaver spot
                {
                    // If "text" dynamic warp location is after an echo or the initial weaver spot location
                    KeyValuePair<string, int> dynamicWarpLocation = warpToPortalWeights.Where(x => x.Key.StartsWith(natUpper.Split('_')[0])).FirstOrDefault();
                    if (dynamicWarpLocation.Key != null && dynamicWarpLocation.Key != "")
                    {
                        key = $"{dynamicWarpLocation.Key.Split('|')[0]}|{natUpper}";
                        // RwLogger.logger.LogInfo($"Checking natural warp weight for region key {key} --");
                        if (warpToPortalWeights.TryGetValue(key, out int weight2))
                        {
                            naturalWeightsForRegion["-" + key] = weight2;
                        }
                    }
                }
            }

            for (int attempt = 0; attempt < testIterations; attempt++)
            {
                string chosen = (string)chooseDynamicWarpTarget.Invoke(null, [world, text, null, false, false, true]);
                text = chosen.ToUpperInvariant();
                world.game.GetStorySession.saveState.miscWorldSaveData.numberOfWarpPointsGenerated++;
                world.name = text.Split('_')[0];
                world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints[text] = "";
                totalDynamicWarps++;

                // Check region's natural warps
                foreach (var warp in unsealedWarps)
                {
                    string warpRegion = warp.ToUpperInvariant().Split('_')[0];
                    if (warpRegion == text.Split('_')[0])
                    {
                        regionNaturalWarps.Add(warp);
                    }
                }
                foreach (var natWarp in regionNaturalWarps)
                {
                    var natUpper = natWarp.ToUpperInvariant();
                    if (natUpper.Split('_')[0] != text.Split('_')[0].ToUpperInvariant()) continue;

                    string key = $"{text}|{natUpper}";
                    if (warpToPortalWeights.TryGetValue(key, out int weight))
                    {
                        naturalWeightsForRegion[key] = weight + attempt + 1;
                    }
                    else
                    {
                        // If "text" dynamic warp location is after an echo or the initial weaver spot location
                        // this will always be a dynamic warp location though?? so prob not needed
                        RwLogger.logger.LogInfo($"Checking natural warp weight for region key {key} -- SOMETHING WENT WRONG");
                        KeyValuePair<string, int> dynamicWarpLocation = warpToPortalWeights.Where(x => x.Key.StartsWith(natUpper.Split('_')[0])).FirstOrDefault();
                        if (dynamicWarpLocation.Key != null && dynamicWarpLocation.Key != "")
                        {
                            key = $"{dynamicWarpLocation.Key.Split('|')[0]}|{natUpper}";
                            RwLogger.logger.LogInfo($"Checking natural warp weight for region key {key} --");
                            if (warpToPortalWeights.TryGetValue(key, out int weight2))
                            {
                                naturalWeightsForRegion[key] = weight2 + attempt + 1;
                            }
                        }
                    }
                }

                if (neededList.Contains(text) || (neededList2.Contains(text) && rippleLvl >= 8)
                    // || (neededList3.Contains(text) && rippleLvl >= 7))
                    || (neededList4.Contains(text) && rippleLvl >= 6))
                {
                    // RwLogger.logger.LogInfo($"Warp {attempt + 1}: {text} - NEEDED");

                    string warpToClose = null;
                    while (warpsToBeClosed.Any(x => text.Split('_')[0].Equals(x.Split('_')[0])
                        && (!laterWarps.Contains(x) || (laterWarps.Contains(x) && rippleLvl >= 8))
                        // && (!laterWarps2.Contains(x) || (laterWarps2.Contains(x) && rippleLvl >= 7)))
                        && (!laterWarps3.Contains(x) || (laterWarps3.Contains(x) && rippleLvl >= 6)))
                        || text.StartsWith("WRRA"))
                    {
                        if (text.StartsWith("WPTA") && !text.Equals("WPTA_F01"))
                        {
                            break; // Hard code not crossing all of signal for echo
                        }
                        warpToClose = warpsToBeClosed.Where(x => x.StartsWith(text.Split('_')[0])).FirstOrDefault();
                        if (warpToClose == null || warpToClose == "")
                        {
                            warpToClose = "WRRA_A26"; // Hard code desolate natural portal
                            closedNaturalWarps.Add(warpToClose);
                            totalWeight += warpToPortalWeights[$"{text}|{warpToClose}"]; // idk, dont count dyn warp LOE cus its technically an "echo"
                        }
                        else
                        {
                            warpsToBeClosed.Remove(warpToClose);
                            closedEchoWarps.Add(warpToClose);
                        }
                        finalPath += searchPath + $"{warpToClose} echo - ";
                        searchPath = "";
                        neededList.RemoveAll(x => x.StartsWith(text.Split('_')[0]));
                        neededList2.RemoveAll(x => x.StartsWith(text.Split('_')[0]));
                        neededList3.RemoveAll(x => x.StartsWith(text.Split('_')[0]));
                        neededList4.RemoveAll(x => x.StartsWith(text.Split('_')[0]));
                        if (text.StartsWith("WTDB"))
                        {
                            neededList.RemoveAll(x => x.StartsWith("WRRA")); // Remove unecessary WRRA warps if WTDB found
                        }
                        CloseWarps(world, warpToClose.ToLowerInvariant());
                        world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints[warpToClose] = "";

                        text = GetDest(warpToClose);
                        if (text == null)
                        {
                            RwLogger.logger.LogInfo($"Error getting destination for closed warp {warpToClose}");
                            return;
                        }
                        world.name = text.Split('_')[0];
                        if (!warpToClose.StartsWith("WTDA") && !warpToClose.StartsWith("WARF") && !warpToClose.StartsWith("WRRA"))
                        // if (!warpToClose.StartsWith("WTDA") && !warpToClose.StartsWith("WARF") && !warpToClose.StartsWith("WRRA")
                        //     && !warpToClose.StartsWith("WBLA") && !warpToClose.StartsWith("WRFB") && !warpToClose.StartsWith("WARE")
                        //     && !warpToClose.StartsWith("WSKC"))
                        {
                            rippleLvl++;
                        }
                    }

                    if (warpsToBeClosed.Count == 0)
                    {
                        // RwLogger.logger.LogInfo($"All echo warps closed. Echo: {closedEchoWarps.Count}, Natural: {closedNaturalWarps.Count}");

                        // Need to close remaining natural warps
                        int naturalWarpsNeeded = naturalWarpsNeed - closedNaturalWarps.Count;
                        if (naturalWarpsNeeded > 0)
                        {
                            // RwLogger.logger.LogInfo($"Need to close {naturalWarpsNeeded} more natural warps");
                        }
                        else
                        {
                            // RwLogger.logger.LogInfo($"All warps closed! Total: {closedEchoWarps.Count + closedNaturalWarps.Count}");
                            break;
                        }
                    }

                    // if (warpToClose != null && warpToClose.Split('_')[0] == "WARB" && i > 20)
                    // {
                    //     world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints = new Dictionary<string, string>(discoveredPoints);
                    //     RwLogger.logger.LogInfo($"Resetting discovered warp points to clear cache.");
                    // }
                    // RwLogger.logger.LogInfo($"Generating warps from {text}");
                    break;
                }
                else
                {
                    dynamicWarpStreak++;
                    // RwLogger.logger.LogInfo($"Warp {attempt + 1}: {text}");
                    searchPath += $"{text} -> ";
                }
            }

            // If no good dynamic warps found for testIterations iterations, try natural warps
            if (dynamicWarpStreak >= testIterations)
            {
                // RwLogger.logger.LogInfo($"No needed warps found in {dynamicWarpStreak} iterations. Checking natural warps...");

                if (regionNaturalWarps.Count > 0)
                {
                    // RwLogger.logger.LogInfo($"Skipping natural warp closure (saving for finale or already completed)");
                    dynamicWarpStreak = 0; // Reset to continue with dynamic warps

                    // Exclude last dynamic warp (it is added again at beginning of this loop)
                    string[] warpStrings = searchPath.Split([" -> "], StringSplitOptions.RemoveEmptyEntries);
                    string strippedSearchPath = "";
                    for (int k = 0; k < warpStrings.Length - 1; k++)
                    {
                        strippedSearchPath += warpStrings[k] + " -> ";
                    }
                    finalPath += strippedSearchPath;
                }
                else
                {
                    // RwLogger.logger.LogInfo($"No natural warps found in regions, ending search.");
                    break;
                }
            }

            // Check completion
            // if (closedEchoWarps.Count + closedNaturalWarps.Count >= totalWarpsNeeded)
            if (closedEchoWarps.Count >= totalWarpsNeeded)
            {
                // RwLogger.logger.LogInfo($"SUCCESS! All {totalWarpsNeeded} warps closed at iteration {i + 1}");
                // RwLogger.logger.LogInfo($"Echo warps: {closedEchoWarps.Count}, Natural warps: {closedNaturalWarps.Count}");
                // RwLogger.logger.LogInfo($"Final path: {finalPath}");
                // RwLogger.logger.LogInfo($"Total dynamic warps: {totalDynamicWarps}, Total nat warp weight: {totalWeight}");
                // RwLogger.logger.LogInfo($"Seed {j}: {totalDynamicWarps}");
                break;
            }
            else if (totalDynamicWarps > 20)
            {
                // RwLogger.logger.LogInfo($"Seed {j}: >20");
                break;
            }
        }
        // RwLogger.logger.LogInfo("---------------------------------------------------------------------------------------------------------------------");

        if (closedEchoWarps.Count < totalWarpsNeeded || totalDynamicWarps >= 20)
        {
            RwLogger.logger.LogInfo($"Seed {j}: ");
            return;
        }

        testIterations = 5;
        // for (int _testIterations = 4; _testIterations < 7; _testIterations++)
        // {
        //     int testIterations = _testIterations;
        // int rippleLvl = 2;
        iterations = 20;
        // bool resetCache = false;

        text = world.name;
        // world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints["WTDA_B01"] = "";
        // RwLogger.logger.LogInfo($"Generating warps starting in room {text}");

        neededList = new List<string>()
        {
            // "WPTA_F01", "WTDB_A17", "WTDB_A15", "WTDB_A13", "WARB_J07", "WRRA_D03", "WRRA_D05",
            //"WARF_B23", "WARF_D29", "WTDA_Z08", "WTDA_Z04",
            //"WSKC_A19",
            // "WVWA_F02",
            //"WARC_C06",
            //"WRFB_B05", "WRFB_D02",
        };
        neededList3 = new List<string>()
        { // Fetid allowed at 8 or more ripple (7 internally here)
            // "WARC_C06",
        };
        neededList4 = new List<string>()
        { // Verdant allowed at 7 or more ripple (6 internally here)
            // "WVWA_F02",
        };
        neededList2 = new List<string>()
        {
            // "WBLA_C02", "WBLA_F04",
            //"WARC_C06",
            // "WVWA_F02",
            // "WARF_B23", "WARF_D29",
        };
        warpsToBeClosed = new List<string>()
        {
            // "WARF_B33", "WBLA_D03", "WTDB_A26", "WARC_F01", "WVWB_A04", "WARE_I14", "WARB_J01", "WPTA_F03", "WSKC_A23", "WTDA_Z14", "WRFB_A22", "WVWA_F03"
        };
        laterWarps = new List<string>()
        {
            "WBLA_D03", "WVWB_A04",
            //"WARC_F01",
            //"WVWA_F03",
            "WARF_B33", "WTDA_Z14",
        };
        laterWarps2 = new List<string>()
        {
            //"WBLA_D03", "WVWB_A04",
            "WARC_F01",
            //"WVWA_F03",
        };
        laterWarps3 = new List<string>()
        {
            //"WBLA_D03", "WVWB_A04",
            // "WARC_F01",
            "WVWA_F03",
        };

        // Track closed warps
        // HashSet<string> closedEchoWarps = [];
        // HashSet<string> closedNaturalWarps = [];
        totalWarpsNeeded = 19; // 12 echo + 7 natural
        naturalWarpsNeed = 7; // 6 cus route include 1 at very beginning
        // string finalPath = "";
        // int totalWeight = 0;
        // int totalDynamicWarps = 0;

        for (int i = 0; i < iterations; i++)
        {
            int dynamicWarpStreak = 0; // Count consecutive dynamic warps without finding needed rooms
            var discoveredPointsBeforeSearch = new Dictionary<string, string>(world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints);

            // Get unsealed natural warps
            List<string> unsealedWarps = world.game.GetStorySession.saveState.RoomsWithWarpsRemainingToBeSealed(false, "");
            List<string> regionNaturalWarps = [];
            string cachedText = text;
            int cachedWorldWarpsGen = world.game.GetStorySession.saveState.miscWorldSaveData.numberOfWarpPointsGenerated;
            string cachedWorldName = world.name;
            string searchPath = $"{text} -> ";

            // Check region's natural warps
            foreach (var warp in unsealedWarps)
            {
                string warpRegion = warp.ToUpperInvariant().Split('_')[0];
                if (warpRegion == text.Split('_')[0])
                {
                    regionNaturalWarps.Add(warp);
                }
            }

            var naturalWeightsForRegion = new Dictionary<string, int>();
            foreach (var natWarp in regionNaturalWarps)
            {
                var natUpper = natWarp.ToUpperInvariant();
                if (natUpper.Split('_')[0] != text.Split('_')[0].ToUpperInvariant()) continue;

                string key = $"{text.ToUpperInvariant()}|{natUpper}";
                // RwLogger.logger.LogInfo($"Checking natural warp weight for region key {key}");
                if (warpToPortalWeights.TryGetValue(key, out int weight))
                {
                    naturalWeightsForRegion[key] = weight;
                }
                // For now just fallback for the final natural warp is in the region u end up in (rare edge case)
                else if (naturalWarpsNeed - closedNaturalWarps.Count == 1)
                {
                    // If "text" dynamic warp location is after an echo or the initial weaver spot location
                    KeyValuePair<string, int> dynamicWarpLocation = warpToPortalWeights.Where(x => x.Key.StartsWith(natUpper.Split('_')[0])).FirstOrDefault();
                    if (dynamicWarpLocation.Key != null && dynamicWarpLocation.Key != "")
                    {
                        key = $"{dynamicWarpLocation.Key.Split('|')[0]}|{natUpper}";
                        // RwLogger.logger.LogInfo($"Checking natural warp weight for region key {key} --");
                        if (warpToPortalWeights.TryGetValue(key, out int weight2))
                        {
                            naturalWeightsForRegion["-" + key] = weight2;
                        }
                    }
                }
            }

            for (int attempt = 0; attempt < testIterations; attempt++)
            {
                string chosen = (string)chooseDynamicWarpTarget.Invoke(null, [world, text, null, false, false, true]);
                text = chosen.ToUpperInvariant();
                world.game.GetStorySession.saveState.miscWorldSaveData.numberOfWarpPointsGenerated++;
                world.name = text.Split('_')[0];
                world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints[text] = "";
                totalDynamicWarps++;

                // Check region's natural warps
                foreach (var warp in unsealedWarps)
                {
                    string warpRegion = warp.ToUpperInvariant().Split('_')[0];
                    if (warpRegion == text.Split('_')[0])
                    {
                        regionNaturalWarps.Add(warp);
                    }
                }
                foreach (var natWarp in regionNaturalWarps)
                {
                    var natUpper = natWarp.ToUpperInvariant();
                    if (natUpper.Split('_')[0] != text.Split('_')[0].ToUpperInvariant()) continue;

                    string key = $"{text}|{natUpper}";
                    if (warpToPortalWeights.TryGetValue(key, out int weight))
                    {
                        naturalWeightsForRegion[key] = weight + attempt + 1;
                    }
                    else
                    {
                        // If "text" dynamic warp location is after an echo or the initial weaver spot location
                        // this will always be a dynamic warp location though?? so prob not needed
                        RwLogger.logger.LogInfo($"Checking natural warp weight for region key {key} -- SOMETHING WENT WRONG");
                        KeyValuePair<string, int> dynamicWarpLocation = warpToPortalWeights.Where(x => x.Key.StartsWith(natUpper.Split('_')[0])).FirstOrDefault();
                        if (dynamicWarpLocation.Key != null && dynamicWarpLocation.Key != "")
                        {
                            key = $"{dynamicWarpLocation.Key.Split('|')[0]}|{natUpper}";
                            RwLogger.logger.LogInfo($"Checking natural warp weight for region key {key} --");
                            if (warpToPortalWeights.TryGetValue(key, out int weight2))
                            {
                                naturalWeightsForRegion[key] = weight2 + attempt + 1;
                            }
                        }
                    }
                }

                dynamicWarpStreak++;
                // RwLogger.logger.LogInfo($"Warp {attempt + 1}: {text}");
                searchPath += $"{text} -> ";
            }

            // If no good dynamic warps found for testIterations iterations, try natural warps
            if (dynamicWarpStreak >= testIterations)
            {
                // RwLogger.logger.LogInfo($"No needed warps found in {dynamicWarpStreak} iterations. Checking natural warps...");

                if (regionNaturalWarps.Count > 0)
                {
                    // Determine if we should close a natural warp
                    int naturalWarpsStillNeeded = naturalWarpsNeed - closedNaturalWarps.Count;

                    // Only close natural warp if:
                    // 1. We need more natural warps closed
                    // 2. It's not the last natural warp (save that for the finale)
                    KeyValuePair<string, int> natWarp = naturalWeightsForRegion.OrderBy(x => x.Value).FirstOrDefault();
                    bool canCloseNatWarp = naturalWarpsStillNeeded > 1 || (naturalWarpsStillNeeded == 1 && warpsToBeClosed.Count == 0);
                    // if (canCloseNatWarp && natWarp.Value > 30 && !resetCache)
                    // {
                    //     world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints = new Dictionary<string, string>(discoveredPoints);
                    //     RwLogger.logger.LogInfo($"PERISH - Resetting discovered warp points to clear cache.");
                    //     resetCache = true;
                    //     text = cachedText;
                    //     world.game.GetStorySession.saveState.miscWorldSaveData.numberOfWarpPointsGenerated = cachedWorldWarpsGen;
                    //     world.name = cachedWorldName;
                    //     // world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints = new Dictionary<string, string>(discoveredPointsBeforeSearch);
                    //     totalDynamicWarps -= testIterations;
                    //     dynamicWarpStreak = 0; // Reset to continue with dynamic warps
                    //     RwLogger.logger.LogInfo($"Restarting warp search back at {text}");
                    // }
                    if (canCloseNatWarp)
                    {
                        string naturalWarpToClose = natWarp.Key.Split('|')[1].ToUpperInvariant();
                        // Dynamic warp to the natural warp region
                        text = cachedText;
                        world.game.GetStorySession.saveState.miscWorldSaveData.numberOfWarpPointsGenerated = cachedWorldWarpsGen;
                        world.name = cachedWorldName;
                        world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints = new Dictionary<string, string>(discoveredPointsBeforeSearch);
                        searchPath = $"{text} -> ";
                        totalDynamicWarps -= testIterations;
                        // RwLogger.logger.LogInfo($"Natural warps found in region. Warping to region {text.Split('_')[0]} to close warp.");
                        // if (naturalWarpToClose.Split('_')[0] == text.Split('_')[0])
                        // {
                        //     RwLogger.logger.LogInfo($"#Something went wrong.#");
                        // }
                        while (!text.Equals(natWarp.Key.Split('|')[0]) && !natWarp.Key.Split('|')[0].StartsWith("-"))
                        {
                            string chosen = (string)chooseDynamicWarpTarget.Invoke(null, [world, text, null, false, false, true]);
                            text = chosen.ToUpperInvariant();
                            world.game.GetStorySession.saveState.miscWorldSaveData.numberOfWarpPointsGenerated++;
                            world.name = text.Split('_')[0];
                            world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints[text] = "";
                            // RwLogger.logger.LogInfo($"Warping to {text}...");
                            searchPath += $"{text} -> ";
                            totalDynamicWarps++;
                        }
                        // RwLogger.logger.LogInfo($"Using natural warp: {naturalWarpToClose} with weight {natWarp.Value}");

                        closedNaturalWarps.Add(naturalWarpToClose);
                        CloseWarps(world, naturalWarpToClose.ToLowerInvariant());
                        world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints[naturalWarpToClose] = "";

                        text = GetDest(naturalWarpToClose);
                        if (text != null)
                        {
                            world.name = text.Split('_')[0];
                            // RwLogger.logger.LogInfo($"Natural warp closed. Moving to {text}. Echo: {closedEchoWarps.Count}, Natural: {closedNaturalWarps.Count}");
                            finalPath += searchPath.Substring(0, searchPath.Length - 3) + "- " + $"{naturalWarpToClose}|{text}({natWarp.Value}) - ";
                            totalWeight += natWarp.Value;
                            dynamicWarpStreak = 0;
                        }
                    }
                    // else if (!resetCache)
                    // {
                    //     world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints = new Dictionary<string, string>(discoveredPoints);
                    //     RwLogger.logger.LogInfo($"PERISH - Resetting discovered warp points to clear cache.");
                    //     resetCache = true;
                    //     text = cachedText;
                    //     world.game.GetStorySession.saveState.miscWorldSaveData.numberOfWarpPointsGenerated = cachedWorldWarpsGen;
                    //     world.name = cachedWorldName;
                    //     // world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints = new Dictionary<string, string>(discoveredPointsBeforeSearch);
                    //     totalDynamicWarps -= testIterations;
                    //     dynamicWarpStreak = 0; // Reset to continue with dynamic warps
                    //     RwLogger.logger.LogInfo($"Restarting warp search back at {text}");
                    // }
                    else
                    {
                        // RwLogger.logger.LogInfo($"Skipping natural warp closure (saving for finale or already completed)");
                        dynamicWarpStreak = 0; // Reset to continue with dynamic warps

                        // Exclude last dynamic warp (it is added again at beginning of this loop)
                        string[] warpStrings = searchPath.Split([" -> "], StringSplitOptions.RemoveEmptyEntries);
                        string strippedSearchPath = "";
                        for (int k = 0; k < warpStrings.Length - 1; k++)
                        {
                            strippedSearchPath += warpStrings[k] + " -> ";
                        }
                        finalPath += strippedSearchPath;
                    }
                }
                else
                {
                    // RwLogger.logger.LogInfo($"No natural warps found in regions, ending search.");
                    RwLogger.logger.LogInfo($"Seed {j}: failed to find natural portals");
                    break;
                }
            }

            // Check completion
            if (closedEchoWarps.Count + closedNaturalWarps.Count >= totalWarpsNeeded)
            {
                RwLogger.logger.LogInfo($"SUCCESS! All {totalWarpsNeeded} warps closed at iteration {i + 1}");
                RwLogger.logger.LogInfo($"Echo warps: {closedEchoWarps.Count}, Natural warps: {closedNaturalWarps.Count}");
                RwLogger.logger.LogInfo($"Final path: {finalPath}");
                RwLogger.logger.LogInfo($"Total dynamic warps: {totalDynamicWarps}, Total nat warp weight: {totalWeight}");
                // RwLogger.logger.LogInfo($"Seed {j}: {totalDynamicWarps + totalWeight}");
                break;
            }
        }
        // RwLogger.logger.LogInfo("---------------------------------------------------------------------------------------------------------------------");
    }

    public void GetFullRoute2(World world, MethodInfo chooseDynamicWarpTarget, int j)
    {
        int testIterations = 5;
        // for (int _testIterations = 4; _testIterations < 7; _testIterations++)
        // {
        //     int testIterations = _testIterations;
        int rippleLvl = 2;
        int iterations = 50;
        // bool resetCache = false;

        string text = world.name;
        // world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints["WTDA_B01"] = "";
        // world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints["WSKA_D10"] = "";
        // RwLogger.logger.LogInfo($"Generating warps starting in room {text}");

        var neededList = new List<string>()
        {
            "WPTA_F01", "WTDB_A17", "WTDB_A15", "WTDB_A13", "WARB_J07", "WRRA_D03", "WRRA_D05",
            //"WARF_B23", "WARF_D29", "WTDA_Z08", "WTDA_Z04",
            //"WSKC_A19",
            // "WVWA_F02",
            //"WARC_C06",
            //"WRFB_B05", "WRFB_D02",
        };
        var neededList3 = new List<string>()
        { // Fetid allowed at 8 or more ripple (7 internally here)
            "WARC_C06",
        };
        var neededList4 = new List<string>()
        { // Verdant allowed at 7 or more ripple (6 internally here)
            "WVWA_F02",
        };
        var neededList2 = new List<string>()
        {
            // "WBLA_C02", "WBLA_F04",
            //"WARC_C06",
            // "WVWA_F02",
            "WARF_B23", "WARF_D29",
        };
        var warpsToBeClosed = new List<string>()
        {
            "WARF_B33", "WBLA_D03", "WTDB_A26", "WARC_F01", "WVWB_A04", "WARE_I14", "WARB_J01", "WPTA_F03", "WSKC_A23", "WTDA_Z14", "WRFB_A22", "WVWA_F03"
        };
        var laterWarps = new List<string>()
        {
            "WBLA_D03", "WVWB_A04",
            //"WARC_F01",
            //"WVWA_F03",
            "WARF_B33", "WTDA_Z14",
        };
        var laterWarps2 = new List<string>()
        {
            //"WBLA_D03", "WVWB_A04",
            "WARC_F01",
            //"WVWA_F03",
        };
        var laterWarps3 = new List<string>()
        {
            //"WBLA_D03", "WVWB_A04",
            // "WARC_F01",
            "WVWA_F03",
        };

        // Track closed warps
        HashSet<string> closedEchoWarps = [];
        HashSet<string> closedNaturalWarps = [];
        int totalWarpsNeeded = 19; // 12 echo + 7 natural
        int naturalWarpsNeed = 7;
        string finalPath = "";
        int totalWeight = 0;
        int totalDynamicWarps = 0;

        for (int i = 0; i < iterations; i++)
        {
            int dynamicWarpStreak = 0; // Count consecutive dynamic warps without finding needed rooms
            var discoveredPointsBeforeSearch = new Dictionary<string, string>(world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints);

            // Get unsealed natural warps
            List<string> unsealedWarps = world.game.GetStorySession.saveState.RoomsWithWarpsRemainingToBeSealed(false, "");
            List<string> regionNaturalWarps = [];
            string cachedText = text;
            int cachedWorldWarpsGen = world.game.GetStorySession.saveState.miscWorldSaveData.numberOfWarpPointsGenerated;
            string cachedWorldName = world.name;
            string searchPath = $"{text} -> ";

            // Check region's natural warps
            foreach (var warp in unsealedWarps)
            {
                string warpRegion = warp.ToUpperInvariant().Split('_')[0];
                if (warpRegion == text.Split('_')[0])
                {
                    regionNaturalWarps.Add(warp);
                }
            }

            var naturalWeightsForRegion = new Dictionary<string, int>();
            foreach (var natWarp in regionNaturalWarps)
            {
                var natUpper = natWarp.ToUpperInvariant();
                if (natUpper.Split('_')[0] != text.Split('_')[0].ToUpperInvariant()) continue;

                string key = $"{text.ToUpperInvariant()}|{natUpper}";
                // RwLogger.logger.LogInfo($"Checking natural warp weight for region key {key}");
                if (warpToPortalWeights.TryGetValue(key, out int weight))
                {
                    naturalWeightsForRegion[key] = weight;
                }
                // For now just fallback for the first warp from weaver spot OR the final natural warp is in the region u end up in (rare edge case)
                else if (i == 0 || (naturalWarpsNeed - closedNaturalWarps.Count == 1 && warpsToBeClosed.Count == 0))
                {
                    // If "text" dynamic warp location is after an echo or the initial weaver spot location
                    KeyValuePair<string, int> dynamicWarpLocation = warpToPortalWeights.Where(x => x.Key.StartsWith(natUpper.Split('_')[0])).FirstOrDefault();
                    if (dynamicWarpLocation.Key != null && dynamicWarpLocation.Key != "")
                    {
                        key = $"{dynamicWarpLocation.Key.Split('|')[0]}|{natUpper}";
                        // RwLogger.logger.LogInfo($"Checking natural warp weight for region key {key} --");
                        if (warpToPortalWeights.TryGetValue(key, out int weight2))
                        {
                            naturalWeightsForRegion["-" + key] = weight2;
                        }
                    }
                }
            }

            // if ((closedNaturalWarps.Count >= 3 && closedEchoWarps.Count != 12) || closedEchoWarps.Count == 12)
            // {
            //     testIterations = Math.Max(5, _testIterations);
            // }
            // else if (closedNaturalWarps.Count < 3 || closedEchoWarps.Count == 12)
            // {
            //     testIterations = _testIterations;
            // }
            for (int attempt = 0; attempt < testIterations; attempt++)
            {
                string chosen = (string)chooseDynamicWarpTarget.Invoke(null, [world, text, null, false, false, true]);
                text = chosen.ToUpperInvariant();
                world.game.GetStorySession.saveState.miscWorldSaveData.numberOfWarpPointsGenerated++;
                world.name = text.Split('_')[0];
                world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints[text] = "";
                totalDynamicWarps++;

                // Check region's natural warps
                foreach (var warp in unsealedWarps)
                {
                    string warpRegion = warp.ToUpperInvariant().Split('_')[0];
                    if (warpRegion == text.Split('_')[0])
                    {
                        regionNaturalWarps.Add(warp);
                    }
                }
                foreach (var natWarp in regionNaturalWarps)
                {
                    var natUpper = natWarp.ToUpperInvariant();
                    if (natUpper.Split('_')[0] != text.Split('_')[0].ToUpperInvariant()) continue;

                    string key = $"{text.ToUpperInvariant()}|{natUpper}";
                    if (warpToPortalWeights.TryGetValue(key, out int weight))
                    {
                        naturalWeightsForRegion[key] = weight + attempt + 1;
                    }
                    else
                    {
                        // If "text" dynamic warp location is after an echo or the initial weaver spot location
                        // this will always be a dynamic warp location though?? so prob not needed
                        RwLogger.logger.LogInfo($"Checking natural warp weight for region key {key} -- SOMETHING WENT WRONG");
                        KeyValuePair<string, int> dynamicWarpLocation = warpToPortalWeights.Where(x => x.Key.StartsWith(natUpper.Split('_')[0])).FirstOrDefault();
                        if (dynamicWarpLocation.Key != null && dynamicWarpLocation.Key != "")
                        {
                            key = $"{dynamicWarpLocation.Key.Split('|')[0]}|{natUpper}";
                            RwLogger.logger.LogInfo($"Checking natural warp weight for region key {key} --");
                            if (warpToPortalWeights.TryGetValue(key, out int weight2))
                            {
                                naturalWeightsForRegion[key] = weight2 + attempt + 1;
                            }
                        }
                    }
                }

                if (neededList.Contains(text) || (neededList2.Contains(text) && rippleLvl >= 8)
                    // || (neededList3.Contains(text) && rippleLvl >= 7))
                    || (neededList4.Contains(text) && rippleLvl >= 6))
                {
                    // RwLogger.logger.LogInfo($"Warp {attempt + 1}: {text} - NEEDED");

                    string warpToClose = null;
                    while (warpsToBeClosed.Any(x => text.Split('_')[0].Equals(x.Split('_')[0])
                        && (!laterWarps.Contains(x) || (laterWarps.Contains(x) && rippleLvl >= 8))
                        // && (!laterWarps2.Contains(x) || (laterWarps2.Contains(x) && rippleLvl >= 7)))
                        && (!laterWarps3.Contains(x) || (laterWarps3.Contains(x) && rippleLvl >= 6)))
                        || text.StartsWith("WRRA"))
                    {
                        if (text.StartsWith("WPTA") && !text.Equals("WPTA_F01"))
                        {
                            break; // Hard code not crossing all of signal for echo
                        }
                        warpToClose = warpsToBeClosed.Where(x => x.StartsWith(text.Split('_')[0])).FirstOrDefault();
                        if (warpToClose == null || warpToClose == "")
                        {
                            warpToClose = "WRRA_A26"; // Hard code desolate natural portal
                            closedNaturalWarps.Add(warpToClose);
                            totalWeight += warpToPortalWeights[$"{text}|{warpToClose}"]; // idk, dont count dyn warp LOE cus its technically an "echo"
                        }
                        else
                        {
                            warpsToBeClosed.Remove(warpToClose);
                            closedEchoWarps.Add(warpToClose);
                        }
                        finalPath += searchPath + $"{warpToClose} echo - ";
                        searchPath = "";
                        neededList.RemoveAll(x => x.StartsWith(text.Split('_')[0]));
                        neededList2.RemoveAll(x => x.StartsWith(text.Split('_')[0]));
                        neededList3.RemoveAll(x => x.StartsWith(text.Split('_')[0]));
                        neededList4.RemoveAll(x => x.StartsWith(text.Split('_')[0]));
                        if (text.StartsWith("WTDB"))
                        {
                            neededList.RemoveAll(x => x.StartsWith("WRRA")); // Remove unecessary WRRA warps if WTDB found
                        }
                        CloseWarps(world, warpToClose.ToLowerInvariant());
                        world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints[warpToClose] = "";

                        text = GetDest(warpToClose);
                        if (text == null)
                        {
                            RwLogger.logger.LogInfo($"Error getting destination for closed warp {warpToClose}");
                            return;
                        }
                        world.name = text.Split('_')[0];
                        if (!warpToClose.StartsWith("WTDA") && !warpToClose.StartsWith("WARF") && !warpToClose.StartsWith("WRRA"))
                        // if (!warpToClose.StartsWith("WTDA") && !warpToClose.StartsWith("WARF") && !warpToClose.StartsWith("WRRA")
                        //     && !warpToClose.StartsWith("WBLA") && !warpToClose.StartsWith("WRFB") && !warpToClose.StartsWith("WARE")
                        //     && !warpToClose.StartsWith("WSKC"))
                        {
                            rippleLvl++;
                        }
                    }

                    if (warpsToBeClosed.Count == 0)
                    {
                        // RwLogger.logger.LogInfo($"All echo warps closed. Echo: {closedEchoWarps.Count}, Natural: {closedNaturalWarps.Count}");

                        // Need to close remaining natural warps
                        int naturalWarpsNeeded = naturalWarpsNeed - closedNaturalWarps.Count;
                        if (naturalWarpsNeeded > 0)
                        {
                            // RwLogger.logger.LogInfo($"Need to close {naturalWarpsNeeded} more natural warps");
                        }
                        else
                        {
                            // RwLogger.logger.LogInfo($"All warps closed! Total: {closedEchoWarps.Count + closedNaturalWarps.Count}");
                            break;
                        }
                    }

                    // if (warpToClose != null && warpToClose.Split('_')[0] == "WARB" && i > 20)
                    // {
                    //     world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints = new Dictionary<string, string>(discoveredPoints);
                    //     RwLogger.logger.LogInfo($"Resetting discovered warp points to clear cache.");
                    // }
                    // RwLogger.logger.LogInfo($"Generating warps from {text}");
                    break;
                }
                else
                {
                    dynamicWarpStreak++;
                    // RwLogger.logger.LogInfo($"Warp {attempt + 1}: {text}");
                    searchPath += $"{text} -> ";
                }
            }

            // If no good dynamic warps found for testIterations iterations, try natural warps
            if (dynamicWarpStreak >= testIterations)
            {
                // RwLogger.logger.LogInfo($"No needed warps found in {dynamicWarpStreak} iterations. Checking natural warps...");

                if (regionNaturalWarps.Count > 0)
                {
                    // Determine if we should close a natural warp
                    int naturalWarpsStillNeeded = naturalWarpsNeed - closedNaturalWarps.Count;

                    // Only close natural warp if:
                    // 1. We need more natural warps closed
                    // 2. It's not the last natural warp (save that for the finale)
                    KeyValuePair<string, int> natWarp = naturalWeightsForRegion.OrderBy(x => x.Value).FirstOrDefault();
                    bool canCloseNatWarp = naturalWarpsStillNeeded > 1 || (naturalWarpsStillNeeded == 1 && warpsToBeClosed.Count == 0);
                    // if (canCloseNatWarp && natWarp.Value > 30 && !resetCache)
                    // {
                    //     world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints = new Dictionary<string, string>(discoveredPoints);
                    //     RwLogger.logger.LogInfo($"PERISH - Resetting discovered warp points to clear cache.");
                    //     resetCache = true;
                    //     text = cachedText;
                    //     world.game.GetStorySession.saveState.miscWorldSaveData.numberOfWarpPointsGenerated = cachedWorldWarpsGen;
                    //     world.name = cachedWorldName;
                    //     // world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints = new Dictionary<string, string>(discoveredPointsBeforeSearch);
                    //     totalDynamicWarps -= testIterations;
                    //     dynamicWarpStreak = 0; // Reset to continue with dynamic warps
                    //     RwLogger.logger.LogInfo($"Restarting warp search back at {text}");
                    // }
                    if (canCloseNatWarp)
                    {
                        string naturalWarpToClose = natWarp.Key.Split('|')[1].ToUpperInvariant();
                        // Dynamic warp to the natural warp region
                        text = cachedText;
                        world.game.GetStorySession.saveState.miscWorldSaveData.numberOfWarpPointsGenerated = cachedWorldWarpsGen;
                        world.name = cachedWorldName;
                        world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints = new Dictionary<string, string>(discoveredPointsBeforeSearch);
                        searchPath = $"{text} -> ";
                        totalDynamicWarps -= testIterations;
                        // RwLogger.logger.LogInfo($"Natural warps found in region. Warping to region {text.Split('_')[0]} to close warp.");
                        // if (naturalWarpToClose.Split('_')[0] == text.Split('_')[0])
                        // {
                        //     RwLogger.logger.LogInfo($"#Something went wrong.#");
                        // }
                        while (!text.Equals(natWarp.Key.Split('|')[0]) && !natWarp.Key.Split('|')[0].StartsWith("-"))
                        {
                            string chosen = (string)chooseDynamicWarpTarget.Invoke(null, [world, text, null, false, false, true]);
                            text = chosen.ToUpperInvariant();
                            world.game.GetStorySession.saveState.miscWorldSaveData.numberOfWarpPointsGenerated++;
                            world.name = text.Split('_')[0];
                            world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints[text] = "";
                            // RwLogger.logger.LogInfo($"Warping to {text}...");
                            searchPath += $"{text} -> ";
                            totalDynamicWarps++;
                        }
                        // RwLogger.logger.LogInfo($"Using natural warp: {naturalWarpToClose} with weight {natWarp.Value}");

                        closedNaturalWarps.Add(naturalWarpToClose);
                        CloseWarps(world, naturalWarpToClose.ToLowerInvariant());
                        world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints[naturalWarpToClose] = "";

                        text = GetDest(naturalWarpToClose);
                        if (text != null)
                        {
                            world.name = text.Split('_')[0];
                            // RwLogger.logger.LogInfo($"Natural warp closed. Moving to {text}. Echo: {closedEchoWarps.Count}, Natural: {closedNaturalWarps.Count}");
                            finalPath += searchPath.Substring(0, searchPath.Length - 3) + "- " + $"{naturalWarpToClose}|{text}({natWarp.Value}) - ";
                            totalWeight += natWarp.Value;
                            dynamicWarpStreak = 0;
                        }
                    }
                    // else if (!resetCache)
                    // {
                    //     world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints = new Dictionary<string, string>(discoveredPoints);
                    //     RwLogger.logger.LogInfo($"PERISH - Resetting discovered warp points to clear cache.");
                    //     resetCache = true;
                    //     text = cachedText;
                    //     world.game.GetStorySession.saveState.miscWorldSaveData.numberOfWarpPointsGenerated = cachedWorldWarpsGen;
                    //     world.name = cachedWorldName;
                    //     // world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints = new Dictionary<string, string>(discoveredPointsBeforeSearch);
                    //     totalDynamicWarps -= testIterations;
                    //     dynamicWarpStreak = 0; // Reset to continue with dynamic warps
                    //     RwLogger.logger.LogInfo($"Restarting warp search back at {text}");
                    // }
                    else
                    {
                        // RwLogger.logger.LogInfo($"Skipping natural warp closure (saving for finale or already completed)");
                        dynamicWarpStreak = 0; // Reset to continue with dynamic warps

                        // Exclude last dynamic warp (it is added again at beginning of this loop)
                        string[] warpStrings = searchPath.Split([" -> "], StringSplitOptions.RemoveEmptyEntries);
                        string strippedSearchPath = "";
                        for (int k = 0; k < warpStrings.Length - 1; k++)
                        {
                            strippedSearchPath += warpStrings[k] + " -> ";
                        }
                        finalPath += strippedSearchPath;
                    }
                }
                else
                {
                    // RwLogger.logger.LogInfo($"No natural warps found in regions, ending search.");
                    break;
                }
            }

            // Check completion
            if (closedEchoWarps.Count + closedNaturalWarps.Count >= totalWarpsNeeded)
            // if (closedEchoWarps.Count >= totalWarpsNeeded)
            {
                // RwLogger.logger.LogInfo($"SUCCESS! All {totalWarpsNeeded} warps closed at iteration {i + 1}");
                // RwLogger.logger.LogInfo($"Echo warps: {closedEchoWarps.Count}, Natural warps: {closedNaturalWarps.Count}");
                // RwLogger.logger.LogInfo($"Final path: {finalPath}");
                // RwLogger.logger.LogInfo($"Total dynamic warps: {totalDynamicWarps}, Total nat warp weight: {totalWeight}");
                RwLogger.logger.LogInfo($"Seed {j}: {totalDynamicWarps + totalWeight}");
                break;
            }
            // else if (totalDynamicWarps > 20)
            // {
            //     RwLogger.logger.LogInfo($"Seed {j}: ");
            //     break;
            // }
        }
        // RwLogger.logger.LogInfo("---------------------------------------------------------------------------------------------------------------------");
        if (closedEchoWarps.Count + closedNaturalWarps.Count < totalWarpsNeeded)
            RwLogger.logger.LogInfo($"Seed {j}: ");
    }

    public void GetEchoRoute(World world, MethodInfo chooseDynamicWarpTarget, int j)
    {
        int testIterations = 10;
        // for (int _testIterations = 4; _testIterations < 7; _testIterations++)
        // {
        //     int testIterations = _testIterations;
        int rippleLvl = 2;
        int iterations = 20;
        // bool resetCache = false;

        string text = world.name;
        // world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints["WTDA_B01"] = "";
        world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints["WSKA_D10"] = "";
        // RwLogger.logger.LogInfo($"Generating warps starting in room {text}");

        var neededList = new List<string>()
        {
            "WPTA_F01", "WTDB_A17", "WTDB_A15", "WTDB_A13", "WARB_J07", "WRRA_D03", "WRRA_D05",
            //"WARF_B23", "WARF_D29", "WTDA_Z08", "WTDA_Z04",
            //"WSKC_A19",
            // "WVWA_F02",
            //"WARC_C06",
            //"WRFB_B05", "WRFB_D02",
        };
        var neededList3 = new List<string>()
        { // Fetid allowed at 8 or more ripple (7 internally here)
            "WARC_C06",
        };
        var neededList4 = new List<string>()
        { // Verdant allowed at 7 or more ripple (6 internally here)
            "WVWA_F02",
        };
        var neededList2 = new List<string>()
        {
            // "WBLA_C02", "WBLA_F04",
            //"WARC_C06",
            // "WVWA_F02",
            "WARF_B23", "WARF_D29",
        };
        var warpsToBeClosed = new List<string>()
        {
            "WARF_B33", "WBLA_D03", "WTDB_A26", "WARC_F01", "WVWB_A04", "WARE_I14", "WARB_J01", "WPTA_F03", "WSKC_A23", "WTDA_Z14", "WRFB_A22", "WVWA_F03"
        };
        var laterWarps = new List<string>()
        {
            "WBLA_D03", "WVWB_A04",
            //"WARC_F01",
            //"WVWA_F03",
            "WARF_B33", "WTDA_Z14",
        };
        var laterWarps2 = new List<string>()
        {
            //"WBLA_D03", "WVWB_A04",
            "WARC_F01",
            //"WVWA_F03",
        };
        var laterWarps3 = new List<string>()
        {
            //"WBLA_D03", "WVWB_A04",
            // "WARC_F01",
            "WVWA_F03",
        };

        // Track closed warps
        HashSet<string> closedEchoWarps = [];
        HashSet<string> closedNaturalWarps = [];
        int totalWarpsNeeded = 12; // 12 echo + 7 natural
        int naturalWarpsNeed = 0;
        string finalPath = "";
        int totalWeight = 0;
        int totalDynamicWarps = 0;

        for (int i = 0; i < iterations; i++)
        {
            int dynamicWarpStreak = 0; // Count consecutive dynamic warps without finding needed rooms
            var discoveredPointsBeforeSearch = new Dictionary<string, string>(world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints);

            // Get unsealed natural warps
            List<string> unsealedWarps = world.game.GetStorySession.saveState.RoomsWithWarpsRemainingToBeSealed(false, "");
            List<string> regionNaturalWarps = [];
            string cachedText = text;
            int cachedWorldWarpsGen = world.game.GetStorySession.saveState.miscWorldSaveData.numberOfWarpPointsGenerated;
            string cachedWorldName = world.name;
            string searchPath = $"{text} -> ";

            // Check region's natural warps
            foreach (var warp in unsealedWarps)
            {
                string warpRegion = warp.ToUpperInvariant().Split('_')[0];
                if (warpRegion == text.Split('_')[0])
                {
                    regionNaturalWarps.Add(warp);
                }
            }

            var naturalWeightsForRegion = new Dictionary<string, int>();
            foreach (var natWarp in regionNaturalWarps)
            {
                var natUpper = natWarp.ToUpperInvariant();
                if (natUpper.Split('_')[0] != text.Split('_')[0].ToUpperInvariant()) continue;

                string key = $"{text.ToUpperInvariant()}|{natUpper}";
                // RwLogger.logger.LogInfo($"Checking natural warp weight for region key {key}");
                if (warpToPortalWeights.TryGetValue(key, out int weight))
                {
                    naturalWeightsForRegion[key] = weight;
                }
                else if (i == 0) // For now just fallback for the first warp from weaver spot
                {
                    // If "text" dynamic warp location is after an echo or the initial weaver spot location
                    KeyValuePair<string, int> dynamicWarpLocation = warpToPortalWeights.Where(x => x.Key.StartsWith(natUpper.Split('_')[0])).FirstOrDefault();
                    if (dynamicWarpLocation.Key != null && dynamicWarpLocation.Key != "")
                    {
                        key = $"{dynamicWarpLocation.Key.Split('|')[0]}|{natUpper}";
                        // RwLogger.logger.LogInfo($"Checking natural warp weight for region key {key} --");
                        if (warpToPortalWeights.TryGetValue(key, out int weight2))
                        {
                            naturalWeightsForRegion["-" + key] = weight2;
                        }
                    }
                }
            }

            // if ((closedNaturalWarps.Count >= 3 && closedEchoWarps.Count != 12) || closedEchoWarps.Count == 12)
            // {
            //     testIterations = Math.Max(5, _testIterations);
            // }
            // else if (closedNaturalWarps.Count < 3 || closedEchoWarps.Count == 12)
            // {
            //     testIterations = _testIterations;
            // }
            for (int attempt = 0; attempt < testIterations; attempt++)
            {
                string chosen = (string)chooseDynamicWarpTarget.Invoke(null, [world, text, null, false, false, true]);
                text = chosen.ToUpperInvariant();
                world.game.GetStorySession.saveState.miscWorldSaveData.numberOfWarpPointsGenerated++;
                world.name = text.Split('_')[0];
                world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints[text] = "";
                totalDynamicWarps++;

                // Check region's natural warps
                foreach (var warp in unsealedWarps)
                {
                    string warpRegion = warp.ToUpperInvariant().Split('_')[0];
                    if (warpRegion == text.Split('_')[0])
                    {
                        regionNaturalWarps.Add(warp);
                    }
                }
                foreach (var natWarp in regionNaturalWarps)
                {
                    var natUpper = natWarp.ToUpperInvariant();
                    if (natUpper.Split('_')[0] != text.Split('_')[0].ToUpperInvariant()) continue;

                    string key = $"{text.ToUpperInvariant()}|{natUpper}";
                    if (warpToPortalWeights.TryGetValue(key, out int weight))
                    {
                        naturalWeightsForRegion[key] = weight + attempt + 1;
                    }
                    else
                    {
                        // If "text" dynamic warp location is after an echo or the initial weaver spot location
                        // this will always be a dynamic warp location though?? so prob not needed
                        RwLogger.logger.LogInfo($"Checking natural warp weight for region key {key} -- SOMETHING WENT WRONG");
                        KeyValuePair<string, int> dynamicWarpLocation = warpToPortalWeights.Where(x => x.Key.StartsWith(natUpper.Split('_')[0])).FirstOrDefault();
                        if (dynamicWarpLocation.Key != null && dynamicWarpLocation.Key != "")
                        {
                            key = $"{dynamicWarpLocation.Key.Split('|')[0]}|{natUpper}";
                            RwLogger.logger.LogInfo($"Checking natural warp weight for region key {key} --");
                            if (warpToPortalWeights.TryGetValue(key, out int weight2))
                            {
                                naturalWeightsForRegion[key] = weight2 + attempt + 1;
                            }
                        }
                    }
                }

                if (neededList.Contains(text) || (neededList2.Contains(text) && rippleLvl >= 8)
                    // || (neededList3.Contains(text) && rippleLvl >= 7))
                    || (neededList4.Contains(text) && rippleLvl >= 6))
                {
                    // RwLogger.logger.LogInfo($"Warp {attempt + 1}: {text} - NEEDED");

                    string warpToClose = null;
                    while (warpsToBeClosed.Any(x => text.Split('_')[0].Equals(x.Split('_')[0])
                        && (!laterWarps.Contains(x) || (laterWarps.Contains(x) && rippleLvl >= 8))
                        // && (!laterWarps2.Contains(x) || (laterWarps2.Contains(x) && rippleLvl >= 7)))
                        && (!laterWarps3.Contains(x) || (laterWarps3.Contains(x) && rippleLvl >= 6)))
                        || text.StartsWith("WRRA"))
                    {
                        if (text.StartsWith("WPTA") && !text.Equals("WPTA_F01"))
                        {
                            break; // Hard code not crossing all of signal for echo
                        }
                        warpToClose = warpsToBeClosed.Where(x => x.StartsWith(text.Split('_')[0])).FirstOrDefault();
                        if (warpToClose == null || warpToClose == "")
                        {
                            warpToClose = "WRRA_A26"; // Hard code desolate natural portal
                            closedNaturalWarps.Add(warpToClose);
                        }
                        else
                        {
                            warpsToBeClosed.Remove(warpToClose);
                            closedEchoWarps.Add(warpToClose);
                        }
                        finalPath += searchPath + $"{warpToClose} echo - ";
                        searchPath = "";
                        neededList.RemoveAll(x => x.StartsWith(text.Split('_')[0]));
                        neededList2.RemoveAll(x => x.StartsWith(text.Split('_')[0]));
                        neededList3.RemoveAll(x => x.StartsWith(text.Split('_')[0]));
                        neededList4.RemoveAll(x => x.StartsWith(text.Split('_')[0]));
                        if (text.StartsWith("WTDB"))
                        {
                            neededList.RemoveAll(x => x.StartsWith("WRRA")); // Remove unecessary WRRA warps if WTDB found
                        }
                        CloseWarps(world, warpToClose.ToLowerInvariant());
                        world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints[warpToClose] = "";

                        text = GetDest(warpToClose);
                        if (text == null)
                        {
                            RwLogger.logger.LogInfo($"Error getting destination for closed warp {warpToClose}");
                            return;
                        }
                        world.name = text.Split('_')[0];
                        if (!warpToClose.StartsWith("WTDA") && !warpToClose.StartsWith("WARF") && !warpToClose.StartsWith("WRRA"))
                        // if (!warpToClose.StartsWith("WTDA") && !warpToClose.StartsWith("WARF") && !warpToClose.StartsWith("WRRA")
                        //     && !warpToClose.StartsWith("WBLA") && !warpToClose.StartsWith("WRFB") && !warpToClose.StartsWith("WARE")
                        //     && !warpToClose.StartsWith("WSKC"))
                        {
                            rippleLvl++;
                        }
                    }

                    if (warpsToBeClosed.Count == 0)
                    {
                        // RwLogger.logger.LogInfo($"All echo warps closed. Echo: {closedEchoWarps.Count}, Natural: {closedNaturalWarps.Count}");

                        // Need to close remaining natural warps
                        int naturalWarpsNeeded = naturalWarpsNeed - closedNaturalWarps.Count;
                        if (naturalWarpsNeeded > 0)
                        {
                            // RwLogger.logger.LogInfo($"Need to close {naturalWarpsNeeded} more natural warps");
                        }
                        else
                        {
                            // RwLogger.logger.LogInfo($"All warps closed! Total: {closedEchoWarps.Count + closedNaturalWarps.Count}");
                            break;
                        }
                    }

                    // if (warpToClose != null && warpToClose.Split('_')[0] == "WARB" && i > 20)
                    // {
                    //     world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints = new Dictionary<string, string>(discoveredPoints);
                    //     RwLogger.logger.LogInfo($"Resetting discovered warp points to clear cache.");
                    // }
                    // RwLogger.logger.LogInfo($"Generating warps from {text}");
                    break;
                }
                else
                {
                    dynamicWarpStreak++;
                    // RwLogger.logger.LogInfo($"Warp {attempt + 1}: {text}");
                    searchPath += $"{text} -> ";
                }
            }

            // If no good dynamic warps found for testIterations iterations, try natural warps
            if (dynamicWarpStreak >= testIterations)
            {
                // RwLogger.logger.LogInfo($"No needed warps found in {dynamicWarpStreak} iterations. Checking natural warps...");

                if (regionNaturalWarps.Count > 0)
                {
                    // Determine if we should close a natural warp
                    int naturalWarpsStillNeeded = naturalWarpsNeed - closedNaturalWarps.Count;

                    // Only close natural warp if:
                    // 1. We need more natural warps closed
                    // 2. It's not the last natural warp (save that for the finale)
                    KeyValuePair<string, int> natWarp = naturalWeightsForRegion.OrderBy(x => x.Value).FirstOrDefault();
                    bool canCloseNatWarp = naturalWarpsStillNeeded > 1 || (naturalWarpsStillNeeded == 1 && warpsToBeClosed.Count == 0);
                    // if (canCloseNatWarp && natWarp.Value > 30 && !resetCache)
                    // {
                    //     world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints = new Dictionary<string, string>(discoveredPoints);
                    //     RwLogger.logger.LogInfo($"PERISH - Resetting discovered warp points to clear cache.");
                    //     resetCache = true;
                    //     text = cachedText;
                    //     world.game.GetStorySession.saveState.miscWorldSaveData.numberOfWarpPointsGenerated = cachedWorldWarpsGen;
                    //     world.name = cachedWorldName;
                    //     // world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints = new Dictionary<string, string>(discoveredPointsBeforeSearch);
                    //     totalDynamicWarps -= testIterations;
                    //     dynamicWarpStreak = 0; // Reset to continue with dynamic warps
                    //     RwLogger.logger.LogInfo($"Restarting warp search back at {text}");
                    // }
                    if (canCloseNatWarp)
                    {
                        string naturalWarpToClose = natWarp.Key.Split('|')[1].ToUpperInvariant();
                        // Dynamic warp to the natural warp region
                        text = cachedText;
                        world.game.GetStorySession.saveState.miscWorldSaveData.numberOfWarpPointsGenerated = cachedWorldWarpsGen;
                        world.name = cachedWorldName;
                        world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints = new Dictionary<string, string>(discoveredPointsBeforeSearch);
                        searchPath = $"{text} -> ";
                        totalDynamicWarps -= testIterations;
                        RwLogger.logger.LogInfo($"Natural warps found in region. Warping to region {text.Split('_')[0]} to close warp.");
                        // if (naturalWarpToClose.Split('_')[0] == text.Split('_')[0])
                        // {
                        //     RwLogger.logger.LogInfo($"#Something went wrong.#");
                        // }
                        while (!text.Equals(natWarp.Key.Split('|')[0]) && !natWarp.Key.Split('|')[0].StartsWith("-"))
                        {
                            string chosen = (string)chooseDynamicWarpTarget.Invoke(null, [world, text, null, false, false, true]);
                            text = chosen.ToUpperInvariant();
                            world.game.GetStorySession.saveState.miscWorldSaveData.numberOfWarpPointsGenerated++;
                            world.name = text.Split('_')[0];
                            world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints[text] = "";
                            RwLogger.logger.LogInfo($"Warping to {text}...");
                            searchPath += $"{text} -> ";
                            totalDynamicWarps++;
                        }
                        RwLogger.logger.LogInfo($"Using natural warp: {naturalWarpToClose} with weight {natWarp.Value}");

                        closedNaturalWarps.Add(naturalWarpToClose);
                        CloseWarps(world, naturalWarpToClose.ToLowerInvariant());
                        world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints[naturalWarpToClose] = "";

                        text = GetDest(naturalWarpToClose);
                        if (text != null)
                        {
                            world.name = text.Split('_')[0];
                            RwLogger.logger.LogInfo($"Natural warp closed. Moving to {text}. Echo: {closedEchoWarps.Count}, Natural: {closedNaturalWarps.Count}");
                            finalPath += searchPath.Substring(0, searchPath.Length - 3) + "- " + $"{naturalWarpToClose}|{text}({natWarp.Value}) - ";
                            totalWeight += natWarp.Value;
                            dynamicWarpStreak = 0;
                        }
                    }
                    // else if (!resetCache)
                    // {
                    //     world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints = new Dictionary<string, string>(discoveredPoints);
                    //     RwLogger.logger.LogInfo($"PERISH - Resetting discovered warp points to clear cache.");
                    //     resetCache = true;
                    //     text = cachedText;
                    //     world.game.GetStorySession.saveState.miscWorldSaveData.numberOfWarpPointsGenerated = cachedWorldWarpsGen;
                    //     world.name = cachedWorldName;
                    //     // world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints = new Dictionary<string, string>(discoveredPointsBeforeSearch);
                    //     totalDynamicWarps -= testIterations;
                    //     dynamicWarpStreak = 0; // Reset to continue with dynamic warps
                    //     RwLogger.logger.LogInfo($"Restarting warp search back at {text}");
                    // }
                    else
                    {
                        // RwLogger.logger.LogInfo($"Skipping natural warp closure (saving for finale or already completed)");
                        dynamicWarpStreak = 0; // Reset to continue with dynamic warps

                        // Exclude last dynamic warp (it is added again at beginning of this loop)
                        string[] warpStrings = searchPath.Split([" -> "], StringSplitOptions.RemoveEmptyEntries);
                        string strippedSearchPath = "";
                        for (int k = 0; k < warpStrings.Length - 1; k++)
                        {
                            strippedSearchPath += warpStrings[k] + " -> ";
                        }
                        finalPath += strippedSearchPath;
                    }
                }
                else
                {
                    // RwLogger.logger.LogInfo($"No natural warps found in regions, ending search.");
                    break;
                }
            }

            // Check completion
            // if (closedEchoWarps.Count + closedNaturalWarps.Count >= totalWarpsNeeded)
            if (closedEchoWarps.Count >= totalWarpsNeeded)
            {
                // RwLogger.logger.LogInfo($"SUCCESS! All {totalWarpsNeeded} warps closed at iteration {i + 1}");
                // RwLogger.logger.LogInfo($"Echo warps: {closedEchoWarps.Count}, Natural warps: {closedNaturalWarps.Count}");
                // RwLogger.logger.LogInfo($"Final path: {finalPath}");
                // RwLogger.logger.LogInfo($"Total dynamic warps: {totalDynamicWarps}, Total nat warp weight: {totalWeight}");
                RwLogger.logger.LogInfo($"Seed {j}: {totalDynamicWarps}");
                break;
            }
            else if (totalDynamicWarps > 20)
            {
                RwLogger.logger.LogInfo($"Seed {j}: ");
                break;
            }
        }
        // RwLogger.logger.LogInfo("---------------------------------------------------------------------------------------------------------------------");
    }

    public void GetNaturalRoute(World world, MethodInfo chooseDynamicWarpTarget)
    {
        int testIterations = 5;
        // for (int _testIterations = 4; _testIterations < 7; _testIterations++)
        // {
        //     int testIterations = _testIterations;
        int rippleLvl = 2;
        int iterations = 100;
        // bool resetCache = false;

        string text = world.name;
        // world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints["WTDA_B01"] = "";
        // RwLogger.logger.LogInfo($"Generating warps starting in room {text}");

        var neededList = new List<string>()
        {
            // "WPTA_F01", "WTDB_A17", "WTDB_A15", "WTDB_A13", "WARB_J07", "WRRA_D03", "WRRA_D05",
            //"WARF_B23", "WARF_D29", "WTDA_Z08", "WTDA_Z04",
            //"WSKC_A19",
            // "WVWA_F02",
            //"WARC_C06",
            //"WRFB_B05", "WRFB_D02",
        };
        var neededList3 = new List<string>()
        { // Fetid allowed at 8 or more ripple (7 internally here)
            // "WARC_C06",
        };
        var neededList4 = new List<string>()
        { // Verdant allowed at 7 or more ripple (6 internally here)
            // "WVWA_F02",
        };
        var neededList2 = new List<string>()
        {
            // "WBLA_C02", "WBLA_F04",
            //"WARC_C06",
            // "WVWA_F02",
            // "WARF_B23", "WARF_D29",
        };
        var warpsToBeClosed = new List<string>()
        {
            // "WARF_B33", "WBLA_D03", "WTDB_A26", "WARC_F01", "WVWB_A04", "WARE_I14", "WARB_J01", "WPTA_F03", "WSKC_A23", "WTDA_Z14", "WRFB_A22", "WVWA_F03"
        };
        var laterWarps = new List<string>()
        {
            "WBLA_D03", "WVWB_A04",
            //"WARC_F01",
            //"WVWA_F03",
            "WARF_B33", "WTDA_Z14",
        };
        var laterWarps2 = new List<string>()
        {
            //"WBLA_D03", "WVWB_A04",
            "WARC_F01",
            //"WVWA_F03",
        };
        var laterWarps3 = new List<string>()
        {
            //"WBLA_D03", "WVWB_A04",
            // "WARC_F01",
            "WVWA_F03",
        };

        // Track closed warps
        HashSet<string> closedEchoWarps = [];
        HashSet<string> closedNaturalWarps = [];
        int totalWarpsNeeded = 19; // 12 echo + 7 natural
        int naturalWarpsNeed = 19; // 6 cus route include 1 at very beginning
        string finalPath = "";
        int totalWeight = 0;
        int totalDynamicWarps = 0;

        for (int i = 0; i < iterations; i++)
        {
            int dynamicWarpStreak = 0; // Count consecutive dynamic warps without finding needed rooms
            var discoveredPointsBeforeSearch = new Dictionary<string, string>(world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints);

            // Get unsealed natural warps
            List<string> unsealedWarps = world.game.GetStorySession.saveState.RoomsWithWarpsRemainingToBeSealed(false, "");
            List<string> regionNaturalWarps = [];
            string cachedText = text;
            int cachedWorldWarpsGen = world.game.GetStorySession.saveState.miscWorldSaveData.numberOfWarpPointsGenerated;
            string cachedWorldName = world.name;
            string searchPath = $"{text} -> ";

            // Check region's natural warps
            foreach (var warp in unsealedWarps)
            {
                string warpRegion = warp.ToUpperInvariant().Split('_')[0];
                if (warpRegion == text.Split('_')[0])
                {
                    regionNaturalWarps.Add(warp);
                }
            }

            var naturalWeightsForRegion = new Dictionary<string, int>();
            foreach (var natWarp in regionNaturalWarps)
            {
                var natUpper = natWarp.ToUpperInvariant();
                if (natUpper.Split('_')[0] != text.Split('_')[0].ToUpperInvariant()) continue;

                string key = $"{text.ToUpperInvariant()}|{natUpper}";
                // RwLogger.logger.LogInfo($"Checking natural warp weight for region key {key}");
                if (warpToPortalWeights.TryGetValue(key, out int weight))
                {
                    naturalWeightsForRegion[key] = weight;
                }
                else if (i == 0) // For now just fallback for the first warp from weaver spot
                {
                    // If "text" dynamic warp location is after an echo or the initial weaver spot location
                    KeyValuePair<string, int> dynamicWarpLocation = warpToPortalWeights.Where(x => x.Key.StartsWith(natUpper.Split('_')[0])).FirstOrDefault();
                    if (dynamicWarpLocation.Key != null && dynamicWarpLocation.Key != "")
                    {
                        key = $"{dynamicWarpLocation.Key.Split('|')[0]}|{natUpper}";
                        // RwLogger.logger.LogInfo($"Checking natural warp weight for region key {key} --");
                        if (warpToPortalWeights.TryGetValue(key, out int weight2))
                        {
                            naturalWeightsForRegion["-" + key] = weight2;
                        }
                    }
                }
            }

            // if ((closedNaturalWarps.Count >= 3 && closedEchoWarps.Count != 12) || closedEchoWarps.Count == 12)
            // {
            //     testIterations = Math.Max(5, _testIterations);
            // }
            // else if (closedNaturalWarps.Count < 3 || closedEchoWarps.Count == 12)
            // {
            //     testIterations = _testIterations;
            // }
            for (int attempt = 0; attempt < testIterations; attempt++)
            {
                string chosen = (string)chooseDynamicWarpTarget.Invoke(null, [world, text, null, false, false, true]);
                text = chosen.ToUpperInvariant();
                world.game.GetStorySession.saveState.miscWorldSaveData.numberOfWarpPointsGenerated++;
                world.name = text.Split('_')[0];
                world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints[text] = "";
                totalDynamicWarps++;

                // Check region's natural warps
                foreach (var warp in unsealedWarps)
                {
                    string warpRegion = warp.ToUpperInvariant().Split('_')[0];
                    if (warpRegion == text.Split('_')[0])
                    {
                        regionNaturalWarps.Add(warp);
                    }
                }
                foreach (var natWarp in regionNaturalWarps)
                {
                    var natUpper = natWarp.ToUpperInvariant();
                    if (natUpper.Split('_')[0] != text.Split('_')[0].ToUpperInvariant()) continue;

                    string key = $"{text.ToUpperInvariant()}|{natUpper}";
                    if (warpToPortalWeights.TryGetValue(key, out int weight))
                    {
                        naturalWeightsForRegion[key] = weight + attempt + 1;
                    }
                    else
                    {
                        // If "text" dynamic warp location is after an echo or the initial weaver spot location
                        // this will always be a dynamic warp location though?? so prob not needed
                        RwLogger.logger.LogInfo($"Checking natural warp weight for region key {key} -- SOMETHING WENT WRONG");
                        KeyValuePair<string, int> dynamicWarpLocation = warpToPortalWeights.Where(x => x.Key.StartsWith(natUpper.Split('_')[0])).FirstOrDefault();
                        if (dynamicWarpLocation.Key != null && dynamicWarpLocation.Key != "")
                        {
                            key = $"{dynamicWarpLocation.Key.Split('|')[0]}|{natUpper}";
                            RwLogger.logger.LogInfo($"Checking natural warp weight for region key {key} --");
                            if (warpToPortalWeights.TryGetValue(key, out int weight2))
                            {
                                naturalWeightsForRegion[key] = weight2 + attempt + 1;
                            }
                        }
                    }
                }

                if (neededList.Contains(text) || (neededList2.Contains(text) && rippleLvl >= 8)
                    // || (neededList3.Contains(text) && rippleLvl >= 7))
                    || (neededList4.Contains(text) && rippleLvl >= 6))
                {
                    // RwLogger.logger.LogInfo($"Warp {attempt + 1}: {text} - NEEDED");

                    string warpToClose = null;
                    while (warpsToBeClosed.Any(x => text.Split('_')[0].Equals(x.Split('_')[0])
                        && (!laterWarps.Contains(x) || (laterWarps.Contains(x) && rippleLvl >= 8))
                        // && (!laterWarps2.Contains(x) || (laterWarps2.Contains(x) && rippleLvl >= 7)))
                        && (!laterWarps3.Contains(x) || (laterWarps3.Contains(x) && rippleLvl >= 6)))
                        || text.StartsWith("WRRA"))
                    {
                        if (text.StartsWith("WPTA") && !text.Equals("WPTA_F01"))
                        {
                            break; // Hard code not crossing all of signal for echo
                        }
                        warpToClose = warpsToBeClosed.Where(x => x.StartsWith(text.Split('_')[0])).FirstOrDefault();
                        if (warpToClose == null || warpToClose == "")
                        {
                            warpToClose = "WRRA_A26"; // Hard code desolate natural portal
                            closedNaturalWarps.Add(warpToClose);
                        }
                        else
                        {
                            warpsToBeClosed.Remove(warpToClose);
                            closedEchoWarps.Add(warpToClose);
                        }
                        finalPath += searchPath + $"{warpToClose} echo - ";
                        searchPath = "";
                        neededList.RemoveAll(x => x.StartsWith(text.Split('_')[0]));
                        neededList2.RemoveAll(x => x.StartsWith(text.Split('_')[0]));
                        neededList3.RemoveAll(x => x.StartsWith(text.Split('_')[0]));
                        neededList4.RemoveAll(x => x.StartsWith(text.Split('_')[0]));
                        if (text.StartsWith("WTDB"))
                        {
                            neededList.RemoveAll(x => x.StartsWith("WRRA")); // Remove unecessary WRRA warps if WTDB found
                        }
                        CloseWarps(world, warpToClose.ToLowerInvariant());
                        world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints[warpToClose] = "";

                        text = GetDest(warpToClose);
                        if (text == null)
                        {
                            RwLogger.logger.LogInfo($"Error getting destination for closed warp {warpToClose}");
                            return;
                        }
                        world.name = text.Split('_')[0];
                        if (!warpToClose.StartsWith("WTDA") && !warpToClose.StartsWith("WARF") && !warpToClose.StartsWith("WRRA"))
                        // if (!warpToClose.StartsWith("WTDA") && !warpToClose.StartsWith("WARF") && !warpToClose.StartsWith("WRRA")
                        //     && !warpToClose.StartsWith("WBLA") && !warpToClose.StartsWith("WRFB") && !warpToClose.StartsWith("WARE")
                        //     && !warpToClose.StartsWith("WSKC"))
                        {
                            rippleLvl++;
                        }
                    }

                    if (warpsToBeClosed.Count == 0)
                    {
                        // RwLogger.logger.LogInfo($"All echo warps closed. Echo: {closedEchoWarps.Count}, Natural: {closedNaturalWarps.Count}");

                        // Need to close remaining natural warps
                        int naturalWarpsNeeded = naturalWarpsNeed - closedNaturalWarps.Count;
                        if (naturalWarpsNeeded > 0)
                        {
                            // RwLogger.logger.LogInfo($"Need to close {naturalWarpsNeeded} more natural warps");
                        }
                        else
                        {
                            // RwLogger.logger.LogInfo($"All warps closed! Total: {closedEchoWarps.Count + closedNaturalWarps.Count}");
                            break;
                        }
                    }

                    // if (warpToClose != null && warpToClose.Split('_')[0] == "WARB" && i > 20)
                    // {
                    //     world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints = new Dictionary<string, string>(discoveredPoints);
                    //     RwLogger.logger.LogInfo($"Resetting discovered warp points to clear cache.");
                    // }
                    // RwLogger.logger.LogInfo($"Generating warps from {text}");
                    break;
                }
                else
                {
                    dynamicWarpStreak++;
                    // RwLogger.logger.LogInfo($"Warp {attempt + 1}: {text}");
                    searchPath += $"{text} -> ";
                }
            }

            // If no good dynamic warps found for testIterations iterations, try natural warps
            if (dynamicWarpStreak >= testIterations)
            {
                // RwLogger.logger.LogInfo($"No needed warps found in {dynamicWarpStreak} iterations. Checking natural warps...");

                if (regionNaturalWarps.Count > 0)
                {
                    // Determine if we should close a natural warp
                    int naturalWarpsStillNeeded = naturalWarpsNeed - closedNaturalWarps.Count;

                    // Only close natural warp if:
                    // 1. We need more natural warps closed
                    // 2. It's not the last natural warp (save that for the finale)
                    KeyValuePair<string, int> natWarp = naturalWeightsForRegion.OrderBy(x => x.Value).FirstOrDefault();
                    bool canCloseNatWarp = naturalWarpsStillNeeded > 1 || (naturalWarpsStillNeeded == 1 && warpsToBeClosed.Count == 0);
                    // if (canCloseNatWarp && natWarp.Value > 30 && !resetCache)
                    // {
                    //     world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints = new Dictionary<string, string>(discoveredPoints);
                    //     RwLogger.logger.LogInfo($"PERISH - Resetting discovered warp points to clear cache.");
                    //     resetCache = true;
                    //     text = cachedText;
                    //     world.game.GetStorySession.saveState.miscWorldSaveData.numberOfWarpPointsGenerated = cachedWorldWarpsGen;
                    //     world.name = cachedWorldName;
                    //     // world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints = new Dictionary<string, string>(discoveredPointsBeforeSearch);
                    //     totalDynamicWarps -= testIterations;
                    //     dynamicWarpStreak = 0; // Reset to continue with dynamic warps
                    //     RwLogger.logger.LogInfo($"Restarting warp search back at {text}");
                    // }
                    if (canCloseNatWarp)
                    {
                        string naturalWarpToClose = natWarp.Key.Split('|')[1].ToUpperInvariant();
                        // Dynamic warp to the natural warp region
                        text = cachedText;
                        world.game.GetStorySession.saveState.miscWorldSaveData.numberOfWarpPointsGenerated = cachedWorldWarpsGen;
                        world.name = cachedWorldName;
                        world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints = new Dictionary<string, string>(discoveredPointsBeforeSearch);
                        searchPath = $"{text} -> ";
                        totalDynamicWarps -= testIterations;
                        RwLogger.logger.LogInfo($"Natural warps found in region. Warping to region {text.Split('_')[0]} to close warp.");
                        // if (naturalWarpToClose.Split('_')[0] == text.Split('_')[0])
                        // {
                        //     RwLogger.logger.LogInfo($"#Something went wrong.#");
                        // }
                        while (!text.Equals(natWarp.Key.Split('|')[0]) && !natWarp.Key.Split('|')[0].StartsWith("-"))
                        {
                            string chosen = (string)chooseDynamicWarpTarget.Invoke(null, [world, text, null, false, false, true]);
                            text = chosen.ToUpperInvariant();
                            world.game.GetStorySession.saveState.miscWorldSaveData.numberOfWarpPointsGenerated++;
                            world.name = text.Split('_')[0];
                            world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints[text] = "";
                            RwLogger.logger.LogInfo($"Warping to {text}...");
                            searchPath += $"{text} -> ";
                            totalDynamicWarps++;
                        }
                        RwLogger.logger.LogInfo($"Using natural warp: {naturalWarpToClose} with weight {natWarp.Value}");

                        closedNaturalWarps.Add(naturalWarpToClose);
                        CloseWarps(world, naturalWarpToClose.ToLowerInvariant());
                        world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints[naturalWarpToClose] = "";

                        text = GetDest(naturalWarpToClose);
                        if (text != null)
                        {
                            world.name = text.Split('_')[0];
                            RwLogger.logger.LogInfo($"Natural warp closed. Moving to {text}. Echo: {closedEchoWarps.Count}, Natural: {closedNaturalWarps.Count}");
                            finalPath += searchPath.Substring(0, searchPath.Length - 3) + "- " + $"{naturalWarpToClose}|{text}({natWarp.Value}) - ";
                            totalWeight += natWarp.Value;
                            dynamicWarpStreak = 0;
                        }
                    }
                    // else if (!resetCache)
                    // {
                    //     world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints = new Dictionary<string, string>(discoveredPoints);
                    //     RwLogger.logger.LogInfo($"PERISH - Resetting discovered warp points to clear cache.");
                    //     resetCache = true;
                    //     text = cachedText;
                    //     world.game.GetStorySession.saveState.miscWorldSaveData.numberOfWarpPointsGenerated = cachedWorldWarpsGen;
                    //     world.name = cachedWorldName;
                    //     // world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints = new Dictionary<string, string>(discoveredPointsBeforeSearch);
                    //     totalDynamicWarps -= testIterations;
                    //     dynamicWarpStreak = 0; // Reset to continue with dynamic warps
                    //     RwLogger.logger.LogInfo($"Restarting warp search back at {text}");
                    // }
                    else
                    {
                        // RwLogger.logger.LogInfo($"Skipping natural warp closure (saving for finale or already completed)");
                        dynamicWarpStreak = 0; // Reset to continue with dynamic warps

                        // Exclude last dynamic warp (it is added again at beginning of this loop)
                        string[] warpStrings = searchPath.Split([" -> "], StringSplitOptions.RemoveEmptyEntries);
                        string strippedSearchPath = "";
                        for (int k = 0; k < warpStrings.Length - 1; k++)
                        {
                            strippedSearchPath += warpStrings[k] + " -> ";
                        }
                        finalPath += strippedSearchPath;
                    }
                }
                else
                {
                    // RwLogger.logger.LogInfo($"No natural warps found in regions, ending search.");
                    break;
                }
            }

            // Check completion
            if (closedEchoWarps.Count + closedNaturalWarps.Count >= totalWarpsNeeded)
            {
                RwLogger.logger.LogInfo($"SUCCESS! All {totalWarpsNeeded} warps closed at iteration {i + 1}");
                RwLogger.logger.LogInfo($"Echo warps: {closedEchoWarps.Count}, Natural warps: {closedNaturalWarps.Count}");
                RwLogger.logger.LogInfo($"Final path: {finalPath}");
                RwLogger.logger.LogInfo($"Total dynamic warps: {totalDynamicWarps}, Total nat warp weight: {totalWeight}");
                // RwLogger.logger.LogInfo($"Seed {j}: {totalDynamicWarps}");
                break;
            }
        }
        // RwLogger.logger.LogInfo("---------------------------------------------------------------------------------------------------------------------");
    }

    public void SearchTrueEnding(World world, MethodInfo chooseDynamicWarpTarget, int i)
    {
        string text = world.name;
        string chosen;

        // chosen = (string)chooseDynamicWarpTarget.Invoke(null, [world, text, null, true, false, true]); // bad warp
        // world.game.GetStorySession.saveState.miscWorldSaveData.numberOfBadWarpsGenerated++;
        // text = chosen.ToUpperInvariant();
        // world.name = text.Split('_')[0];
        // // probably dont need to save in discovered warps since they're temporary one ways
        // // RwLogger.logger.LogInfo($"Bad Warp: {text}");

        // chosen = (string)chooseDynamicWarpTarget.Invoke(null, [world, text, null, false, true, true]); // dynamic rot warp
        // world.game.GetStorySession.saveState.miscWorldSaveData.numberOfWarpPointsGenerated++;
        // text = chosen.ToUpperInvariant();
        // world.name = text.Split('_')[0];
        // world.game.GetStorySession.saveState.miscWorldSaveData.regionsInfectedBySentientRot.Add(text.Split('_')[0].ToLowerInvariant());
        // AddNewRegion(world, text.Split('_')[0]);
        // world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints[text] = "";
        // // RwLogger.logger.LogInfo($"Dynamic Warp: {text}");

        // if (text.Equals("WRFB_D02") || text.Equals("WRFB_B11") || text.Equals("WRFB_B05"))
        // {
        //     chosen = (string)chooseDynamicWarpTarget.Invoke(null, [world, text, null, false, true, true]); // dynamic rot warp
        //     world.game.GetStorySession.saveState.miscWorldSaveData.numberOfWarpPointsGenerated++;
        //     text = chosen.ToUpperInvariant();
        //     world.name = text.Split('_')[0];
        //     world.game.GetStorySession.saveState.miscWorldSaveData.regionsInfectedBySentientRot.Add(text.Split('_')[0].ToLowerInvariant());
        //     AddNewRegion(world, text.Split('_')[0]);
        //     world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints[text] = "";
        //     // RwLogger.logger.LogInfo($"Dynamic Warp: {text}");
        //     if (text.Equals("WSKA_D01"))
        //     {
        //         RwLogger.logger.LogInfo($"{i}");
        //     }
        // }

        chosen = (string)chooseDynamicWarpTarget.Invoke(null, [world, text, null, false, false, true]); // dynamic warp
        world.game.GetStorySession.saveState.miscWorldSaveData.numberOfWarpPointsGenerated++;
        // text = chosen.ToUpperInvariant();
        // world.name = text.Split('_')[0];
        AddNewRegion(world, chosen.ToUpperInvariant().Split('_')[0]);
        world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints[chosen.ToUpperInvariant()] = "";
        // RwLogger.logger.LogInfo($"Dynamic Warp: {chosen.ToUpperInvariant()}");

        if (chosen.ToUpperInvariant().Equals("WPGA_B12") || chosen.ToUpperInvariant().Equals("WRFA_SK02") || chosen.ToUpperInvariant().Equals("WTDA_B01") || chosen.ToUpperInvariant().Equals("WSKD_B35") || chosen.ToUpperInvariant().Equals("WBLA_D02") || chosen.ToUpperInvariant().Equals("WARF_A01") || chosen.ToUpperInvariant().Equals("WRFA_A08"))
        {
            chosen = (string)chooseDynamicWarpTarget.Invoke(null, [world, text, null, false, false, true]); // dynamic warp
            world.game.GetStorySession.saveState.miscWorldSaveData.numberOfWarpPointsGenerated++;
            text = chosen.ToUpperInvariant();
            world.name = text.Split('_')[0];
            AddNewRegion(world, text.Split('_')[0]);
            world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints[chosen.ToUpperInvariant()] = "";
            // RwLogger.logger.LogInfo($"Dynamic Warp: {text}");
            if (chosen.ToUpperInvariant().Equals("WRRA_D03"))
            {
                RwLogger.logger.LogInfo($"{i}");
                // chosen = (string)chooseDynamicWarpTarget.Invoke(null, [world, text, null, false, false, true]); // dynamic warp
                // world.game.GetStorySession.saveState.miscWorldSaveData.numberOfWarpPointsGenerated++;
                // text = chosen.ToUpperInvariant();
                // world.name = text.Split('_')[0];
                // world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints[chosen.ToUpperInvariant()] = "";
                // // RwLogger.logger.LogInfo($"Dynamic Warp: {text}");
                // if (chosen.ToUpperInvariant().Equals("WRFB_D02") || chosen.ToUpperInvariant().Equals("WRFB_B11") || chosen.ToUpperInvariant().Equals("WRFB_B05"))
                // {
                //     RwLogger.logger.LogInfo($"{i}");
                // }
            }
        }
    }

    public void SearchTrueEnding2(World world, MethodInfo chooseDynamicWarpTarget, int i)
    {
        // int rippleLvl = 6; // + badlands + turbulent + heat ducts + stormy
        string text = world.name;
        string chosen;
        // string chosen = (string)chooseDynamicWarpTarget.Invoke(null, [world, text, null, true, false, true]); // bad warp
        // world.game.GetStorySession.saveState.miscWorldSaveData.numberOfBadWarpsGenerated++;
        // text = chosen.ToUpperInvariant();
        // world.name = text.Split('_')[0];
        // // probably dont need to save in discovered warps since they're temporary one ways
        // // RwLogger.logger.LogInfo($"Bad Warp: {text}");

        // chosen = (string)chooseDynamicWarpTarget.Invoke(null, [world, text, null, false, true, true]); // dynamic rot warp
        // world.game.GetStorySession.saveState.miscWorldSaveData.numberOfWarpPointsGenerated++;
        // text = chosen.ToUpperInvariant();
        // world.name = text.Split('_')[0];
        // world.game.GetStorySession.saveState.miscWorldSaveData.regionsInfectedBySentientRot.Add(text.Split('_')[0].ToLowerInvariant());
        // world.game.GetStorySession.saveState.regionStates.Add(null);
        // world.game.GetStorySession.saveState.regionLoadStrings.Add($"<rgB>{text.Split('_')[0]}<rgA>");
        // world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints[text] = "";
        // RwLogger.logger.LogInfo($"Dynamic Warp: {text}");
        // if (text.Equals("WARB_J07"))
        // {
        //     RwLogger.logger.LogInfo($"{i}");
        // world.game.GetStorySession.saveState.deathPersistentSaveData.rippleLevel += (float)0.5;
        // world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints = new Dictionary<string, string>(discoveredPoints);

        // world.game.GetStorySession.saveState.deathPersistentSaveData.rippleLevel -= (float)0.5;
        // }

        chosen = (string)chooseDynamicWarpTarget.Invoke(null, [world, text, "WORA", true, false, true]); // bad warp to OR
        world.game.GetStorySession.saveState.miscWorldSaveData.numberOfBadWarpsGenerated++;
        text = chosen.ToUpperInvariant();
        world.name = text.Split('_')[0];
        // probably dont need to save in discovered warps since they're temporary one ways
        // RwLogger.logger.LogInfo($"Bad Warp: {text}");

        chosen = (string)chooseDynamicWarpTarget.Invoke(null, [world, text, null, false, true, true]); // dynamic rot warp

        // world.game.GetStorySession.saveState.miscWorldSaveData.numberOfWarpPointsGenerated++;
        text = chosen.ToUpperInvariant();
        world.name = text.Split('_')[0];
        // world.game.GetStorySession.saveState.miscWorldSaveData.regionsInfectedBySentientRot.Add(text.Split('_')[0].ToLowerInvariant());
        // world.game.GetStorySession.saveState.regionStates.Add(null);
        // world.game.GetStorySession.saveState.regionLoadStrings.Add($"<rgB>{text.Split('_')[0]}<rgA>");
        // world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints[text] = "";
        // RwLogger.logger.LogInfo($"Dynamic Warp: {text}"); // wrra_d05
        if (text.Equals("WSKA_D10"))
        {
            RwLogger.logger.LogInfo($"{i}");
        }
    }

    public void GetNext10Warps(World world, MethodInfo chooseDynamicWarpTarget)
    {
        string text = world.name;
        for (int i = 0; i < 10; i++)
        {
            string chosen = (string)chooseDynamicWarpTarget.Invoke(null, [world, text, null, false, false, true]);
            text = chosen.ToUpperInvariant();
            world.game.GetStorySession.saveState.miscWorldSaveData.numberOfWarpPointsGenerated++;
            world.name = text.Split('_')[0];
            world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints[text] = "";
            RwLogger.logger.LogInfo($"Warp {i + 1}: {text}");
        }
    }

    public void HardCodedWeaverRoute(World world, MethodInfo chooseDynamicWarpTarget, int i)
    {
        string text = world.name;
        string chosen = (string)chooseDynamicWarpTarget.Invoke(null, [world, text, null, false, false, true]);
        text = chosen.ToUpperInvariant();
        world.game.GetStorySession.saveState.miscWorldSaveData.numberOfWarpPointsGenerated++;
        world.name = text.Split('_')[0];
        world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints[text] = "";
        // RwLogger.logger.LogInfo($"Warp {i + 1}: {text}");
        // RwLogger.logger.LogInfo($"Checking Seed: {i}");
        string warpToClose;
        // if (text.Equals("WARB_J07"))
        // {
        //     string warpToClose = "WARB_J01";
        if (text.Equals("WPTA_F01"))
        {
            warpToClose = "WPTA_F03";
            CloseWarps(world, warpToClose.ToLowerInvariant());
            world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints[warpToClose] = "";

            text = GetDest(warpToClose);
            world.name = text.Split('_')[0];

            chosen = (string)chooseDynamicWarpTarget.Invoke(null, [world, text, null, false, false, true]);
            text = chosen.ToUpperInvariant();
            world.game.GetStorySession.saveState.miscWorldSaveData.numberOfWarpPointsGenerated++;
            world.name = text.Split('_')[0];
            world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints[text] = "";

            // if (text.Equals("WPTA_F01"))
            // {
            //     warpToClose = "WPTA_F03";
            if (text.Equals("WARB_J07"))
            {
                warpToClose = "WARB_J01";
                CloseWarps(world, warpToClose.ToLowerInvariant());
                world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints[warpToClose] = "";

                text = GetDest(warpToClose);
                world.name = text.Split('_')[0];

                chosen = (string)chooseDynamicWarpTarget.Invoke(null, [world, text, null, false, false, true]);
                text = chosen.ToUpperInvariant();
                world.game.GetStorySession.saveState.miscWorldSaveData.numberOfWarpPointsGenerated++;
                world.name = text.Split('_')[0];
                world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints[text] = "";
                RwLogger.logger.LogInfo($"Both: {i}");

                if (text.Equals("WTDB_A15"))
                {
                    warpToClose = "WTDB_A26";
                    CloseWarps(world, warpToClose.ToLowerInvariant());
                    world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints[warpToClose] = "";

                    text = GetDest(warpToClose);
                    world.name = text.Split('_')[0];

                    chosen = (string)chooseDynamicWarpTarget.Invoke(null, [world, text, null, false, false, true]);
                    text = chosen.ToUpperInvariant();
                    world.game.GetStorySession.saveState.miscWorldSaveData.numberOfWarpPointsGenerated++;
                    world.name = text.Split('_')[0];
                    world.game.GetStorySession.saveState.miscWorldSaveData.discoveredWarpPoints[text] = "";
                    RwLogger.logger.LogInfo($"Seed Found: {i} !!!!!!!!!!!!!!!!!!!!!!!!!!");
                }
            }
        }
    }

    public void AddNewRegion(World world, string region)
    {
        string regionTag = $"<rgB>{region}<rgA>";
        bool regionExists = false;
        foreach (var rl in world.game.GetStorySession.saveState.regionLoadStrings)
        {
            if (!string.IsNullOrEmpty(rl) && rl.Contains(regionTag))
            {
                regionExists = true;
                break;
            }
        }
        if (!regionExists)
        {
            for (int i = 0; i < world.game.GetStorySession.saveState.regionLoadStrings.Length; i++)
            {
                if (string.IsNullOrEmpty(world.game.GetStorySession.saveState.regionLoadStrings[i]))
                {
                    world.game.GetStorySession.saveState.regionLoadStrings[i] = regionTag;
                    break;
                }
            }
        }
    }

    // I hope this is pass by reference (c#....)
    public void CloseWarps(World world, string room)
    {
        // Watcher seals
        // RwLogger.logger.LogInfo($"Watcher closing warps: ");
        if (!world.game.GetStorySession.saveState.miscWorldSaveData.roomsSealedByWeaverAbility.Contains(room))
        {
            world.game.GetStorySession.saveState.miscWorldSaveData.roomsSealedByWeaverAbility.Add(room);
            // RwLogger.logger.LogInfo($"{room}");
        }
        string destRoom = GetDest(room);
        if (destRoom != null && !world.game.GetStorySession.saveState.miscWorldSaveData.roomsSealedByWeaverAbility.Contains(destRoom.ToLowerInvariant()))
        {
            world.game.GetStorySession.saveState.miscWorldSaveData.roomsSealedByWeaverAbility.Add(destRoom.ToLowerInvariant());
            // RwLogger.logger.LogInfo($"{destRoom.ToLowerInvariant()}");
        }

        // Weaver seals
        List<string> list = world.game.GetStorySession.saveState.RoomsWithWarpsRemainingToBeSealed(RWCustom.Custom.rainWorld.progression.miscProgressionData.beaten_Watcher_SpinningTop, "");
        if (list.Count > 2)
        {
            list.Sort();
            UnityEngine.Random.State state = UnityEngine.Random.state;
            UnityEngine.Random.InitState(RWCustom.Custom.rainWorld.progression.miscProgressionData.watcherCampaignSeed + list.Count);
            string closeWarp = list[UnityEngine.Random.Range(0, list.Count)].ToLowerInvariant();
            UnityEngine.Random.state = state;
            // Search discovered/spawned warps?
            string closeWarpDest = GetDest(closeWarp);
            // RwLogger.logger.LogInfo($"Weaver closing warps: ");
            if (!world.game.GetStorySession.saveState.miscWorldSaveData.roomsSealedByVoidWeaver.Contains(closeWarp))
            {
                world.game.GetStorySession.saveState.miscWorldSaveData.roomsSealedByVoidWeaver.Add(closeWarp);
                // RwLogger.logger.LogInfo($"{closeWarp}");
            }
            // Always assume closeWarpDest is not null?
            if (!world.game.GetStorySession.saveState.miscWorldSaveData.roomsSealedByVoidWeaver.Contains(closeWarpDest.ToLowerInvariant()))
            {
                world.game.GetStorySession.saveState.miscWorldSaveData.roomsSealedByVoidWeaver.Add(closeWarpDest.ToLowerInvariant());
                // RwLogger.logger.LogInfo($"{closeWarpDest.ToLowerInvariant()}");
            }
            string[] array3 = ["ward_r10", "wssr_cramped", "wssr_lab6"];
            for (int m = 0; m < array3.Length; m++)
            {
                if (!world.game.GetStorySession.saveState.miscWorldSaveData.roomsSealedByVoidWeaver.Contains(array3[m]) && !world.game.GetStorySession.saveState.miscWorldSaveData.roomsSealedByWeaverAbility.Contains(array3[m]))
                {
                    world.game.GetStorySession.saveState.miscWorldSaveData.roomsSealedByVoidWeaver.Add(array3[m]);
                    // RwLogger.logger.LogInfo($"{array3[m]}");
                }
            }
        }
    }

    // Won't look in discovered/spawned warps (does that matter?)
    // Returns room in UPPERCASE
    public string GetDest(string room)
    {
        string text2 = null;
        string text = room.ToLowerInvariant();
        foreach (KeyValuePair<string, List<string>> keyValuePair3 in RWCustom.Custom.rainWorld.regionWarpRooms)
        {
            for (int k = 0; k < keyValuePair3.Value.Count; k++)
            {
                string[] array = keyValuePair3.Value[k].Split(':');
                if (array[0].ToLowerInvariant() == text && array.Length > 3)
                {
                    text2 = array[3];
                    break;
                }
            }
            if (text2 != null)
            {
                break;
            }
        }
        if (text2 == null) // Search ST warps if not found
        {
            foreach (KeyValuePair<string, List<string>> keyValuePair4 in RWCustom.Custom.rainWorld.regionSpinningTopRooms)
            {
                for (int l = 0; l < keyValuePair4.Value.Count; l++)
                {
                    string[] array2 = keyValuePair4.Value[l].Split(':');
                    if (array2[0].ToLowerInvariant() == text && array2.Length > 2)
                    {
                        text2 = array2[2];
                        break;
                    }
                }
                if (text2 != null)
                {
                    break;
                }
            }
        }
        return text2?.ToUpperInvariant();
    }
}